{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap","webpack:///./src/puzzle.js","webpack:///./src/puzzle-cell.js","webpack:///./src/puzzle-line.js","webpack:///./src/utility.js","webpack:///./src/creator.js","webpack:///./src/solver.js","webpack:///./src/gui.js","webpack:///./src/gui-template.js","webpack:///./src/puzzle-library.js","webpack:///./src/export.js"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","__webpack_exports__","_nonogram__WEBPACK_IMPORTED_MODULE_0__","_nonogram__WEBPACK_IMPORTED_MODULE_0___default","a","Puzzle","[object Object]","width","height","toString","this","parseInt","totalCells","reset","zeroFill","Utility","getZeroFilledArray","creator","cells","rowHints","columnHints","grid","map","every","cell","userValue","userSolution","solution","row","start","end","push","length","column","index","indexInt","PuzzleCell","params","aiSolution","assign","PuzzleLine","type","minimumSectionLength","sections","solved","array","indexOf","splice","Array","fill","slice","min","max","minCeil","Math","ceil","maxFloor","floor","random","Creator","density","Date","getTime","cellsFilled","chanceOfCellFill","solutionGrid","rowArray","cellValue","solver","elapsed","puzzleValid","densityValid","puzzle","_reset","getRandomIntBetween","_log","_populatePuzzleFromGrid","Solver","solve","elapsedTime","_logLine","creationTime","solvingTime","forEach","rowKey","hints","columnKey","solvedCell","cellIndex","puzzleCell","getCellByIndex","currentVal","lastVal","hintKey","hint","msg","log","passStart","passEnd","passElapsedTime","totalElapsedTime","lineKey","line","lastProgress","pass","isReset","_getProgress","_getTotalSolved","lines","eliminateImpossibleFits","findKnownPositivesAndNegatives","findSectionDefiningChains","findAnchoredSections","findCompletedSections","findCompletedLines","section","possibleStartIndex","newPossibleStartIndexes","lineSectionKey","startIndexKey","testCell","lineCellKey","minimumStartIndex","maximumStartIndex","_setCellSolution","cloneArray","possibleStartIndexes","removeFromArray","totalCellCounts","sectionKey","cellCounts","cellCountKey","cellCount","fillRange","firstSection","lastSection","cellKey","chain","chainKey","sectionsSorted","firstSortedSection","chains","lastValue","sort","b","firstNegative","lastNegative","totalSectionLength","totalPositiveSolved","possibleRowIndexes","possibleColumnIndexes","rowNumber","rowCells","len","columnHint","solutionLog","getRowCells","knownIndexes","getColumnCells","isRow","isCol","cellsSolved","html","cssClass","total","maxPossibilities","totalPossibilities","Gui","theme","head","document","querySelector","link","createElement","boardSizes","handle","size","boardSize","themePath","_resolveThemePath","themeStylesheetPath","rel","href","prepend","templatesLoaded","themeTemplatesPath","templates","GuiTemplate","template","load","Promise","all","then","drawGenerateControls","drawPuzzle","drawGameControls","drawConsole","_getTemplate","gridContainer","container","node","getNode","theadThTemplate","rowTemplate","cellClasses","tl","tr","bl","br","columnIndex","theadTh","importNode","content","fillDiv","setAttribute","classList","add","span","textContent","appendChild","parentNode","insertBefore","cellTemplate","hintsFillDiv","td","keys","innerHtml","_resizeBoardForAvailableScreen","_makePuzzlePlayable","drawPreview","fillModeCheckbox","addEventListener","fillModeLabel","prevActive","prevInactive","remove","checked","playerClickMode","e","dispatchEvent","MouseEvent","widthSelect","heightSelect","widthOptions","heightOptions","chooseExampleSelect","boardSizeSelect","boardSizeOptions","clonedWidthOptions","cloneHeightOptions","widthOption","heightOption","clonedExampleOptions","exampleOption","chooseSelect","clonedSizeOptions","sizeOption","generate","PuzzleLibrary","puzzleName","selectedExample","sizeObj","createRandom","draw","puzzleDef","createFromGrid","createFromHints","item","_changeBoardSize","_resetPuzzle","drawSolution","_showPuzzleSolved","output","text","code","solutionType","canvas","ctx","getContext","parentContainer","parentElement","parentWidth","offsetWidth","parentHeight","offsetHeight","containerRatio","puzzleRatio","cellSize","fillRect","querySelectorAll","cellElem","puzzleTable","sizeSelect","table","availableWidth","clientWidth","sortedBoardSizes","allCells","hoverCell","currentTarget","getAttribute","solvedP","preventDefault","toggle","checkUserSolution","cellElems","puzzleGrid","innerHTML","tableCells","ret","find","path","script","url","URL","src","fileName","pathname","split","pop","replace","err","onLoadedCallbacks","isLoaded","loadedPromise","callback","resolve","fetch","response","ok","fireOnLoaded","div","Small Example 1","Small Example 2","Small Example 3","Medium Example 1","Medium Example 2","Large Example 1"],"mappings":"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","file":"nonogram.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Nonogram\"] = factory();\n\telse\n\t\troot[\"Nonogram\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"dist/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n","import Nonogram from './nonogram';\r\n\r\n\r\n/**\r\n * @class\r\n * @type {Nonogram.Puzzle}\r\n * @this Nonogram.Puzzle\r\n *\r\n * the main puzzle class containing the grid of cells, row/column hints, etc.\r\n *\r\n * @property {number} width\r\n * @property {number} height\r\n * @property {number} totalCells\r\n * @property {array} cells\r\n * @property {array} rowHints\r\n * @property {array} columnHints\r\n * @property {Nonogram.Creator|null} creator\r\n * @property {array} grid - a multi-dimensional array representing rows and columns.\r\n *                   for example a 2x2 grid could be represented by [[0,1],[0,0]]\r\n */\r\nNonogram.Puzzle = class\r\n{\r\n\t/**\r\n\t * @param {number} width - an integer >= 1 specifying the number of rows\r\n\t * @param {number} height - an integer >= 1 specifying the number of columns\r\n\t * @throws - error if width or height are invalid\r\n\t */\r\n\tconstructor( width, height )\r\n\t{\r\n\t\tif (typeof width === 'undefined' || typeof height === 'undefined') {\r\n\r\n\t\t\tthrow('width and height are required constructor parameters.');\r\n\r\n\t\t} else if ((width <= 0 || height <= 0) || (width === 1 && height === 1)) {\r\n\r\n\t\t\tthrow('invalid dimensions: ' + width.toString() + ' x ' + height.toString());\r\n\t\t}\r\n\r\n\t\tthis.width      = typeof width === 'number' ? width : parseInt( width.toString(), 10 );\r\n\t\tthis.height     = typeof height === 'number' ? height : parseInt( height.toString(), 10 );\r\n\t\tthis.totalCells = this.width * this.height;\r\n\r\n\t\tthis.reset();\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * empty all arrays and create zero-filled multidimensional grid array\r\n\t */\r\n\treset()\r\n\t{\r\n\t\tconst zeroFill = Nonogram.Utility.getZeroFilledArray;\r\n\r\n\t\tthis.creator     = null;\r\n\t\tthis.cells       = [];\r\n\t\tthis.rowHints    = [];\r\n\t\tthis.columnHints = [];\r\n\t\tthis.grid        = zeroFill( this.height ).map( () =>\r\n\t\t{\r\n\t\t\treturn zeroFill( this.width );\r\n\t\t} );\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * @returns {boolean}\r\n\t */\r\n\tcheckUserSolution()\r\n\t{\r\n\t\treturn this.cells.every( ( cell ) =>\r\n\t\t{\r\n\t\t\t// cell.solution will be 0 or 1, but cell.userSolution might be null, 0 or 1\r\n\t\t\tconst userValue = cell.userSolution === 1 ? 1 : 0;\r\n\r\n\t\t\treturn cell.solution === userValue;\r\n\t\t} );\r\n\t}\r\n\t\r\n\r\n\t/**\r\n\t * @param {number} row\r\n\t * @returns {array|boolean}\r\n\t */\r\n\tgetRowCells( row )\r\n\t{\r\n\t\tconst cells = [];\r\n\t\tlet start   = row * this.width,\r\n\t\t\tend     = start + this.width,\r\n\t\t\ti\r\n\t\t;\r\n\r\n\t\tfor (i = start; i < end; i++) {\r\n\t\t\tcells.push( this.cells[i] );\r\n\t\t}\r\n\r\n\t\treturn cells.length > 0 ? cells : false;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * @param {number} column\r\n\t * @returns {array|boolean}\r\n\t */\r\n\tgetColumnCells( column )\r\n\t{\r\n\t\tconst cells = [];\r\n\t\tlet i;\r\n\r\n\t\tfor (i = column; i < this.cells.length; i += this.width) {\r\n\t\t\tcells.push( this.cells[i] );\r\n\t\t}\r\n\r\n\t\treturn cells.length > 0 ? cells : false;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * @param {number|string} index\r\n\t * @returns {object|boolean}\r\n\t */\r\n\tgetCellByIndex( index )\r\n\t{\r\n\t\tconst indexInt = typeof index !== 'number' ? parseInt( index, 10 ) : index;\r\n\r\n\t\treturn this.cells[indexInt] ? this.cells[indexInt] : false;\r\n\t}\r\n\r\n};\r\n\r\n\r\n\r\n","import Nonogram from './nonogram';\r\n\r\n\r\n/**\r\n * @class\r\n * @type {Nonogram.PuzzleCell}\r\n * @this Nonogram.PuzzleCell\r\n *\r\n * a container representing a single cell in the puzzle grid\r\n *\r\n * @property {number} index\r\n * @property {number} column\r\n * @property {number} row\r\n * @property {number|null} solution\r\n * @property {number|null} userSolution\r\n * @property {number|null} aiSolution\r\n */\r\nNonogram.PuzzleCell = class\r\n{\r\n\tconstructor( params )\r\n\t{\r\n\t\tthis.index        = -1;\r\n\t\tthis.column       = -1;\r\n\t\tthis.row          = -1;\r\n\t\tthis.solution     = null;\r\n\t\tthis.userSolution = null;\r\n\t\tthis.aiSolution   = null;\r\n\r\n\t\tObject.assign( this, params );\r\n\t}\r\n};\r\n","import Nonogram from './nonogram';\r\n\r\n\r\n/**\r\n * @class\r\n * @type {Nonogram.PuzzleLine}\r\n * @this Nonogram.PuzzleLine\r\n *\r\n * a container representing a complete row or column of grid cells\r\n *\r\n * @property {string} type - either 'row' or 'column'\r\n * @property {number} index - the column or row index\r\n * @property {number} length\r\n * @property {number} minimumSectionLength\r\n * @property {array} sections\r\n * @property {array} cells\r\n * @property {boolean} solved\r\n */\r\nNonogram.PuzzleLine = class\r\n{\r\n\tconstructor( params )\r\n\t{\r\n\t\tthis.type                 = '';\r\n\t\tthis.index                = -1;\r\n\t\tthis.length               = 0;\r\n\t\tthis.minimumSectionLength = 0;\r\n\t\tthis.sections             = [];\r\n\t\tthis.cells                = [];\r\n\t\tthis.solved               = false;\r\n\r\n\t\tObject.assign( this, params );\r\n\t}\r\n};\r\n\r\n\r\n","import Nonogram from './nonogram';\r\n\r\n\r\n/**\r\n * @class\r\n * @type {Nonogram.Utility}\r\n * @this Nonogram.Utility\r\n */\r\nNonogram.Utility = class\r\n{\r\n\t/**\r\n\t *\r\n\t * @param array\r\n\t * @param value\r\n\t * @returns {array}\r\n\t */\r\n\tstatic removeFromArray( array, value )\r\n\t{\r\n\t\tconst index = array.indexOf( value );\r\n\r\n\t\tif (index !== -1) {\r\n\t\t\tarray.splice( index, 1 );\r\n\t\t}\r\n\r\n\t\treturn array;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t *\r\n\t * @param length\r\n\t * @returns {array}\r\n\t */\r\n\tstatic getZeroFilledArray( length )\r\n\t{\r\n\t\treturn new Array( length ).fill( 0 );\r\n\t}\r\n\r\n\r\n\t/**\r\n\t *\r\n\t * @param array\r\n\t * @returns {array}\r\n\t */\r\n\tstatic cloneArray( array )\r\n\t{\r\n\t\treturn array.slice( 0 );\r\n\t}\r\n\r\n\r\n\t/**\r\n\t *\r\n\t * @param min\r\n\t * @param max\r\n\t * @returns {number}\r\n\t */\r\n\tstatic getRandomIntBetween( min, max )\r\n\t{\r\n\t\tlet minCeil  = Math.ceil( min ),\r\n\t\t\tmaxFloor = Math.floor( max )\r\n\t\t;\r\n\r\n\t\treturn Math.floor( Math.random() * (maxFloor - minCeil + 1) ) + minCeil;\r\n\t}\r\n\r\n};","import Nonogram from './nonogram';\r\n\r\n\r\n/**\r\n * @class\r\n * @type {Nonogram.Creator}\r\n * @this Nonogram.Creator\r\n *\r\n * creates nonogram puzzles\r\n *\r\n * @property {Nonogram.Puzzle} puzzle\r\n * @property {array} _log\r\n * @property {number} creationTime\r\n * @property {number} solvingTime\r\n */\r\nNonogram.Creator = class\r\n{\r\n\r\n\r\n\t// ######################################################################################\tpublic methods\r\n\r\n\t/**\r\n\t * populates the puzzles rows and columns with random, solvable values\r\n\t *\r\n\t * @param {number} width\r\n\t * @param {number} height\r\n\t * @param {number|null} density - a floating point number between 0 and 1 (optional) that controls the percentage of filled cell likelihood.\r\n\t *                                    If not supplied a random value between 0.2 and 0.8 will be generated.\r\n\t *                                    Note that this does not make a puzzle grid filled in by the percentage,\r\n\t *                                    rather it's a 'suggestion' that is run through randomization on a cell-by-cell basis.\r\n\t * @returns {Nonogram.Puzzle|Puzzle|class}\r\n\t */\r\n\tcreateRandom( width, height, density )\r\n\t{\r\n\t\tconst start      = new Date().getTime();\r\n\t\tlet puzzleValid  = false,\r\n\t\t\tdensityValid = typeof density === 'number' && density >= 0 && density <= 1,\r\n\t\t\tcellsFilled, chanceOfCellFill, solutionGrid, rowArray, cellValue, solver, i, elapsed\r\n\t\t;\r\n\r\n\r\n\t\tthis.puzzle = new Nonogram.Puzzle( width, height );\r\n\t\tthis._reset();\r\n\r\n\r\n\t\twhile (puzzleValid === false) {\r\n\r\n\t\t\tchanceOfCellFill = densityValid ? density : Nonogram.Utility.getRandomIntBetween( 200, 800 ) / 1000;\r\n\t\t\tsolutionGrid     = [];\r\n\t\t\trowArray         = [];\r\n\t\t\tcellsFilled      = 0;\r\n\r\n\t\t\tthis._log( 'Creating random ' +\r\n\t\t\t\tthis.puzzle.width + 'x' + this.puzzle.height +\r\n\t\t\t\t' puzzle with density of ' + chanceOfCellFill + '...'\r\n\t\t\t);\r\n\r\n\t\t\t// create puzzle grid randomly using density as a factor\r\n\r\n\t\t\tfor (i = 0; i < this.puzzle.totalCells; i++) {\r\n\r\n\t\t\t\tcellValue = Math.random() < chanceOfCellFill ? 1 : 0;\r\n\r\n\t\t\t\tcellsFilled += cellValue;\r\n\r\n\t\t\t\tif (i % this.puzzle.width === 0 && i > 0) {\r\n\t\t\t\t\tsolutionGrid.push( rowArray );\r\n\t\t\t\t\trowArray = [];\r\n\t\t\t\t}\r\n\r\n\t\t\t\trowArray.push( cellValue );\r\n\t\t\t}\r\n\r\n\t\t\t// ensure that at least one cell is filled, and that not all of them are\r\n\r\n\t\t\tif (cellsFilled === 0) {\r\n\r\n\t\t\t\tthis._log( 'Generated puzzle has no cells filled.  Trying again...' );\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\t} else if (cellsFilled === this.puzzle.totalCells) {\r\n\r\n\t\t\t\tthis._log( 'Generated puzzle has all cells filled.  Trying again...' );\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\r\n\t\t\t// populate the solution grid\r\n\t\t\tsolutionGrid.push( rowArray );\r\n\r\n\t\t\t// populate the grid\r\n\t\t\tthis.puzzle = Nonogram.Creator._populatePuzzleFromGrid( this.puzzle, solutionGrid );\r\n\r\n\r\n\t\t\t// ensure that puzzle is solvable\r\n\t\t\tsolver = new Nonogram.Solver( this.puzzle );\r\n\r\n\t\t\tif (solver.solve()) {\r\n\r\n\t\t\t\tpuzzleValid = true;\r\n\t\t\t\telapsed     = (new Date().getTime() - start) / 1000;\r\n\r\n\t\t\t\tthis._log( 'Puzzle is solvable - solved in ' + solver.elapsedTime + ' seconds' );\r\n\t\t\t\tthis._logLine();\r\n\t\t\t\tthis._log( 'Puzzle generated in ' + elapsed + ' seconds.' );\r\n\r\n\t\t\t\tthis.creationTime = elapsed;\r\n\t\t\t\tthis.solvingTime  = solver.elapsedTime;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis._log( 'Puzzle cannot be solved.  Trying again...' );\r\n\t\t\t}\r\n\r\n\t\t\tthis._logLine();\r\n\t\t}\r\n\r\n\t\tthis.puzzle.creator = this;\r\n\r\n\t\treturn this.puzzle;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * - create a puzzle using a grid\r\n\t *\r\n\t * @param {array} grid - a multi-dimensional array representing rows and columns.\r\n\t *                         for example a 2x2 grid could be represented by [[0,1],[0,0]]\r\n\t * @throws - error if grid is invalid\r\n\t */\r\n\tcreateFromGrid( grid )\r\n\t{\r\n\t\tconst start = new Date();\r\n\t\tlet width   = 0,\r\n\t\t\theight  = 0,\r\n\t\t\tpuzzle, solver, elapsed\r\n\t\t;\r\n\r\n\t\tthis._reset();\r\n\r\n\t\tthis._log( 'creating puzzle from grid array.' );\r\n\r\n\t\t// make sure grid is valid and get width & height\r\n\t\tif (!grid instanceof Array) {\r\n\t\t\tthrow 'grid is not an array';\r\n\t\t}\r\n\r\n\r\n\t\tgrid.forEach( ( row, rowKey ) =>\r\n\t\t{\r\n\t\t\tif (!row instanceof Array) {\r\n\t\t\t\tthrow 'grid is not a multi-dimensional array';\r\n\t\t\t}\r\n\r\n\t\t\tif (width === 0) {\r\n\t\t\t\twidth = row.length;\r\n\t\t\t} else if (row.length !== width) {\r\n\t\t\t\tthrow 'row ' + rowKey + ' has an invalid length (' + row.length + ') - expecting ' + width;\r\n\t\t\t}\r\n\r\n\t\t\theight++;\r\n\t\t} );\r\n\r\n\t\tthis._log( 'grid is valid' );\r\n\t\tthis._log( 'populating ' + width + 'x' + height + ' puzzle' );\r\n\r\n\t\tpuzzle = new Nonogram.Puzzle( width, height );\r\n\r\n\t\tthis.puzzle         = Nonogram.Creator._populatePuzzleFromGrid( puzzle, grid );\r\n\t\tthis.puzzle.creator = this;\r\n\r\n\t\t// ensure that puzzle is solvable\r\n\r\n\t\tsolver = new Nonogram.Solver( this.puzzle );\r\n\r\n\r\n\t\tif (solver.solve()) {\r\n\r\n\t\t\tthis._log( 'Puzzle is solvable.' );\r\n\t\t\tthis._logLine();\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis._log( 'Puzzle cannot be solved.' );\r\n\t\t\tthis._logLine();\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\telapsed = (new Date().getTime() - start) / 1000;\r\n\r\n\t\tthis._log( 'Puzzle built and solved in ' + elapsed + ' seconds.' );\r\n\t\tthis._logLine();\r\n\r\n\t\treturn this.puzzle;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * - create a puzzle from a hint object\r\n\t *\r\n\t * @param {object} hints - structured like this:  {\r\n\t * \t\t\t\t\t\t\t\t\trow: [[3], [5], [5], [2, 3], [1, 5], [2, 1, 1], [2, 5], [1, 3]],\r\n\t\t\t\t\t\t\t\t\t\tcolumn: [[1, 3], [4], [], [2, 3], [5, 2], [5, 2], [5, 2], [2, 3]]\r\n\t\t\t\t\t\t\t\t\t}\r\n\t * @param {array} hints.row\r\n\t * @param {array} hints.column\r\n\t * @throws - error if hints object is structured incorrectly\r\n\t */\r\n\tcreateFromHints( hints )\r\n\t{\r\n\t\tconst start = new Date();\r\n\t\tlet width, height, puzzle, solver, elapsed;\r\n\r\n\t\tthis._reset();\r\n\r\n\t\tthis._log( 'creating puzzle from hints' );\r\n\r\n\t\t// make sure row & column properties exist\r\n\r\n\t\tif (typeof hints !== 'object' || !hints.row || !hints.column) {\r\n\r\n\t\t\tthrow 'parameter passed to createFromHints() must be an object containing \"row\" and \"column\" properties';\r\n\r\n\t\t} else if (!hints.row instanceof Array || !hints.column instanceof Array) {\r\n\r\n\t\t\tthrow 'hints.row or hints.column must be an array.';\r\n\t\t}\r\n\t\tthis._log( 'found row and column hints' );\r\n\r\n\t\twidth              = hints.column.length;\r\n\t\theight             = hints.row.length;\r\n\t\tpuzzle             = new Nonogram.Puzzle( width, height );\r\n\t\tpuzzle.rowHints    = hints.row;\r\n\t\tpuzzle.columnHints = hints.column;\r\n\t\tpuzzle.creator     = this;\r\n\r\n\t\tthis._log( 'populating ' + width + 'x' + height + ' puzzle' );\r\n\r\n\r\n\t\t// populate cells array\r\n\r\n\t\tpuzzle.grid.forEach( ( row, rowKey ) =>\r\n\t\t{\r\n\t\t\trow.forEach( ( column, columnKey ) =>\r\n\t\t\t{\r\n\t\t\t\tpuzzle.cells.push( new Nonogram.PuzzleCell( {\r\n\t\t\t\t\tindex:  (rowKey * puzzle.width) + columnKey,\r\n\t\t\t\t\tcolumn: columnKey,\r\n\t\t\t\t\trow:    rowKey\r\n\t\t\t\t} ) );\r\n\t\t\t} );\r\n\t\t} );\r\n\r\n\t\tthis.puzzle = puzzle;\r\n\r\n\r\n\t\t// ensure that puzzle is solvable\r\n\r\n\t\tsolver = new Nonogram.Solver( this.puzzle );\r\n\r\n\r\n\t\tif (solver.solve()) {\r\n\r\n\t\t\tthis._log( 'Puzzle is solvable.' );\r\n\t\t\tthis._logLine();\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis._log( 'Puzzle cannot be solved.' );\r\n\t\t\tthis._logLine();\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\t// set solution on puzzle cells\r\n\r\n\t\tsolver.puzzle.cells.forEach( ( solvedCell, cellIndex ) =>\r\n\t\t{\r\n\t\t\tconst puzzleCell = this.puzzle.getCellByIndex( cellIndex );\r\n\r\n\t\t\tpuzzleCell.aiSolution = solvedCell.aiSolution;\r\n\t\t\tpuzzleCell.solution   = solvedCell.aiSolution;\r\n\t\t} );\r\n\r\n\t\telapsed = (new Date().getTime() - start) / 1000;\r\n\r\n\t\tthis._log( 'Puzzle built and solved in ' + elapsed + ' seconds.' );\r\n\t\tthis._logLine();\r\n\r\n\t\treturn this.puzzle;\r\n\t}\r\n\r\n\r\n\t// ######################################################################################\tprivate methods\r\n\r\n\t/**\r\n\t *\r\n\t * @param {Nonogram.Puzzle} puzzle\r\n\t * @param {array} grid - a multidimensional array\r\n\t * @returns {Nonogram.Puzzle} puzzle\r\n\t * @private\r\n\t */\r\n\tstatic _populatePuzzleFromGrid( puzzle, grid )\r\n\t{\r\n\t\tlet columnHints, rowKey, row, columnKey, column, cell, currentVal, lastVal, rowHints, hintKey, hint;\r\n\r\n\t\tpuzzle.reset();\r\n\r\n\t\tpuzzle.grid = grid;\r\n\r\n\r\n\t\tfor (rowKey = 0; rowKey < puzzle.grid.length; rowKey++) {\r\n\r\n\t\t\trow      = puzzle.grid[rowKey];\r\n\t\t\trowHints = [];\r\n\r\n\t\t\tpuzzle.rowHints[rowKey] = [];\r\n\r\n\t\t\tfor (columnKey = 0; columnKey < row.length; columnKey++) {\r\n\r\n\t\t\t\tcolumn     = row[columnKey];\r\n\t\t\t\tcurrentVal = column;\r\n\t\t\t\tlastVal    = columnKey > 0 ? puzzle.grid[rowKey][columnKey - 1] : 0;\r\n\r\n\t\t\t\t// populate cells\r\n\r\n\t\t\t\tpuzzle.cells.push( new Nonogram.PuzzleCell( {\r\n\t\t\t\t\tindex:    (rowKey * puzzle.width) + columnKey,\r\n\t\t\t\t\tcolumn:   columnKey,\r\n\t\t\t\t\trow:      rowKey,\r\n\t\t\t\t\tsolution: column\r\n\t\t\t\t} ) );\r\n\r\n\t\t\t\t// populate row hints\r\n\r\n\t\t\t\tif (currentVal === 1 && lastVal === 0) {\r\n\t\t\t\t\trowHints.push( 1 );\r\n\t\t\t\t} else if (currentVal === 0 && lastVal === 1) {\r\n\t\t\t\t\trowHints.push( 0 );\r\n\t\t\t\t} else if (currentVal === 1 && lastVal === 1) {\r\n\t\t\t\t\trowHints[rowHints.length - 1]++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// clean up row hints\r\n\r\n\t\t\tfor (hintKey = 0; hintKey < rowHints.length; hintKey++) {\r\n\r\n\t\t\t\thint = rowHints[hintKey];\r\n\r\n\t\t\t\tif (hint > 0) {\r\n\t\t\t\t\tpuzzle.rowHints[rowKey].push( hint );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// populate column hints\r\n\r\n\t\tfor (columnKey = 0; columnKey < puzzle.width; columnKey++) {\r\n\r\n\t\t\tpuzzle.columnHints[columnKey] = [];\r\n\t\t\tcolumnHints                   = [];\r\n\r\n\t\t\tfor (cell = columnKey; cell < puzzle.totalCells; cell += puzzle.width) {\r\n\r\n\t\t\t\trow        = Math.floor( cell / puzzle.width );\r\n\t\t\t\tcurrentVal = puzzle.grid[row][columnKey];\r\n\t\t\t\tlastVal    = row > 0 ? puzzle.grid[row - 1][columnKey] : 0;\r\n\r\n\t\t\t\tif (currentVal === 1 && lastVal === 0) {\r\n\t\t\t\t\tcolumnHints.push( 1 );\r\n\t\t\t\t} else if (currentVal === 0 && lastVal === 1) {\r\n\t\t\t\t\tcolumnHints.push( 0 );\r\n\t\t\t\t} else if (currentVal === 1 && lastVal === 1) {\r\n\t\t\t\t\tcolumnHints[columnHints.length - 1]++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// clean up column hints\r\n\r\n\t\t\tfor (hintKey = 0; hintKey < columnHints.length; hintKey++) {\r\n\r\n\t\t\t\thint = rowHints[hintKey];\r\n\r\n\t\t\t\tif (hint > 0) {\r\n\t\t\t\t\tpuzzle.columnHints[columnKey].push( hint );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn puzzle;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t *\r\n\t * @param msg\r\n\t * @private\r\n\t */\r\n\t_log( msg )\r\n\t{\r\n\t\tthis.log.push( msg );\r\n\t}\r\n\r\n\r\n\t/**\r\n\t *\r\n\t * @private\r\n\t */\r\n\t_logLine()\r\n\t{\r\n\t\tthis.log.push( '-----------------------------------' );\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\t_reset()\r\n\t{\r\n\t\tthis.log          = [];\r\n\t\tthis.creationTime = 0;\r\n\t\tthis.solvingTime  = 0;\r\n\t}\r\n\r\n\r\n};\r\n\r\n","import Nonogram from './nonogram';\r\n\r\n\r\n/**\r\n * @class\r\n * @type {Nonogram.Solver}\r\n * @this Nonogram.Solver\r\n *\r\n * a class that solves nonogram puzzles using logical techniques a human might use\r\n *\r\n * @property {Nonogram.Puzzle} puzzle\r\n * @property {number} elapsedTime\r\n * @property {boolean} isReset\r\n * @property {array} lines\r\n * @property {array} solutionLog\r\n */\r\nNonogram.Solver = class\r\n{\r\n\r\n\t/**\r\n\t * @param {Nonogram.Puzzle} puzzle\r\n\t */\r\n\tconstructor( puzzle )\r\n\t{\r\n\t\tthis.puzzle = puzzle;\r\n\r\n\t\tthis._reset();\r\n\t}\r\n\r\n\r\n\t/**\r\n\t *\r\n\t * @returns {boolean}\r\n\t */\r\n\tsolve()\r\n\t{\r\n\t\tconst start      = new Date().getTime();\r\n\t\tlet lastProgress = -1,\r\n\t\t\tpass         = 1,\r\n\t\t\tsolved, passStart, passEnd, end, passElapsedTime, totalElapsedTime, lineKey, line\r\n\t\t;\r\n\r\n\t\tif (!this.isReset) {\r\n\t\t\tthis._reset();\r\n\t\t}\r\n\r\n\t\tthis.isReset = false;\r\n\t\tthis._log( 'Starting solve algorithm', 'info' );\r\n\r\n\r\n\t\twhile (this._getProgress() > lastProgress && this._getTotalSolved() < this.puzzle.cells.length) {\r\n\r\n\t\t\tpassStart    = new Date().getTime();\r\n\t\t\tlastProgress = this._getProgress();\r\n\r\n\t\t\tfor (lineKey = 0; lineKey < this.lines.length; lineKey++) {\r\n\r\n\t\t\t\tline = this.lines[lineKey];\r\n\r\n\t\t\t\tif (!line.solved) {\r\n\t\t\t\t\tthis.eliminateImpossibleFits( line );\r\n\t\t\t\t}\r\n\t\t\t\tif (!line.solved) {\r\n\t\t\t\t\tthis.findKnownPositivesAndNegatives( line );\r\n\t\t\t\t}\r\n\t\t\t\tif (!line.solved) {\r\n\t\t\t\t\tthis.findSectionDefiningChains( line );\r\n\t\t\t\t}\r\n\t\t\t\tif (!line.solved) {\r\n\t\t\t\t\tthis.findAnchoredSections( line );\r\n\t\t\t\t}\r\n\t\t\t\tif (!line.solved) {\r\n\t\t\t\t\tthis.findCompletedSections( line );\r\n\t\t\t\t}\r\n\t\t\t\tif (!line.solved) {\r\n\t\t\t\t\tthis.findCompletedLines( line );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tpassEnd         = new Date().getTime();\r\n\t\t\tpassElapsedTime = (passEnd - passStart) / 1000;\r\n\r\n\t\t\tthis._log( 'Pass ' + pass + ' completed in ' + passElapsedTime + ' seconds :: '\r\n\t\t\t\t+ this._getTotalSolved() + '/' + this.puzzle.cells.length + ' cells solved', 'info'\r\n\t\t\t);\r\n\t\t\tpass++;\r\n\t\t}\r\n\r\n\t\tsolved           = this._getTotalSolved() === this.puzzle.cells.length;\r\n\t\tend              = new Date().getTime();\r\n\t\ttotalElapsedTime = (end - start) / 1000;\r\n\r\n\t\tthis._log( 'Solve algorithm finished in ' + totalElapsedTime + ' seconds.', 'info' );\r\n\r\n\t\tif (solved) {\r\n\t\t\tthis._log( 'Solution Found.', 'success' );\r\n\t\t} else {\r\n\t\t\tthis._log( 'Could not find solution.', 'failure' );\r\n\t\t}\r\n\r\n\t\tthis.elapsedTime = totalElapsedTime;\r\n\r\n\t\treturn solved;\r\n\t}\r\n\r\n\r\n\t//\t#############################################################################################\tsolution algorithms\r\n\r\n\t/**\r\n\t *\r\n\t * @param {Nonogram.PuzzleLine} line\r\n\t */\r\n\teliminateImpossibleFits( line )\r\n\t{\r\n\t\tlet minimumStartIndex = 0,\r\n\t\t\tmaximumStartIndex = line.length - line.minimumSectionLength,\r\n\t\t\ti, section, possibleStartIndex, newPossibleStartIndexes, lineSectionKey, startIndexKey, testCell, end,\r\n\t\t\tlineCellKey, lineKey\r\n\t\t;\r\n\r\n\r\n\t\t// no sections\r\n\r\n\t\tif (line.sections.length === 0) {\r\n\r\n\t\t\tfor (lineCellKey = 0; lineCellKey < line.cells.length; lineCellKey++) {\r\n\t\t\t\tthis._setCellSolution( line.cells[lineCellKey], 0 );\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// tighten range if one or more known negative cells start the line\r\n\r\n\t\tfor (lineKey = 0; lineKey < line.length; lineKey++) {\r\n\r\n\t\t\tif (line.cells[lineKey].aiSolution === 0) {\r\n\t\t\t\tminimumStartIndex++;\r\n\t\t\t} else {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// tighten range if one or more known negative cells end the line\r\n\r\n\t\tfor (lineKey = line.length - 1; lineKey >= 0; lineKey--) {\r\n\t\t\tif (line.cells[lineKey].aiSolution === 0) {\r\n\t\t\t\tmaximumStartIndex--;\r\n\t\t\t} else {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\r\n\t\tfor (lineSectionKey = 0; lineSectionKey < line.sections.length; lineSectionKey++) {\r\n\r\n\t\t\tsection                 = line.sections[lineSectionKey];\r\n\t\t\tnewPossibleStartIndexes = Nonogram.Utility.cloneArray( section.possibleStartIndexes );\r\n\r\n\t\t\t// eliminate places where section does not fit\r\n\r\n\t\t\tfor (startIndexKey = 0; startIndexKey < section.possibleStartIndexes.length; startIndexKey++) {\r\n\r\n\t\t\t\tpossibleStartIndex = section.possibleStartIndexes[startIndexKey];\r\n\r\n\t\t\t\ttestCell = line.cells[possibleStartIndex + section.length];\r\n\r\n\t\t\t\t// the total length of all sections including minimum gap(s) of one cell does not allow this section to fit:\r\n\r\n\t\t\t\tif (possibleStartIndex < minimumStartIndex || possibleStartIndex > maximumStartIndex) {\r\n\t\t\t\t\tnewPossibleStartIndexes = Nonogram.Utility.removeFromArray( newPossibleStartIndexes, possibleStartIndex );\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// there is a known positive cell immediately following the possible section placement, so section cannot start here\r\n\r\n\t\t\t\tif (testCell && testCell.aiSolution === 1) {\r\n\t\t\t\t\tnewPossibleStartIndexes = Nonogram.Utility.removeFromArray( newPossibleStartIndexes, possibleStartIndex );\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// there is a known impossible cell in this range, so section cannot fit here:\r\n\r\n\t\t\t\tend = possibleStartIndex + section.length - 1;\r\n\t\t\t\tend = (end > line.length - 1) ? line.length - 1 : end;\r\n\r\n\t\t\t\tfor (i = possibleStartIndex; i <= end; i++) {\r\n\t\t\t\t\tif (i > line.length - 1 || line.cells[i].aiSolution === 0) {\r\n\t\t\t\t\t\tnewPossibleStartIndexes = Nonogram.Utility.removeFromArray( newPossibleStartIndexes, possibleStartIndex );\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\r\n\t\t\tminimumStartIndex += section.length + 1;\r\n\t\t\tmaximumStartIndex += section.length + 1;\r\n\r\n\t\t\tsection.possibleStartIndexes = newPossibleStartIndexes;\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t/**\r\n\t *\r\n\t * @param {Nonogram.PuzzleLine} line\r\n\t */\r\n\tfindKnownPositivesAndNegatives( line )\r\n\t{\r\n\t\tconst totalCellCounts = Nonogram.Utility.getZeroFilledArray( line.length );\r\n\t\tlet sectionKey, section, cellCounts, startIndexKey, possibleStartIndex, start, end, i, cellCountKey, cellCount,\r\n\t\t\tcell;\r\n\r\n\t\tfor (sectionKey = 0; sectionKey < line.sections.length; sectionKey++) {\r\n\r\n\t\t\tsection    = line.sections[sectionKey];\r\n\t\t\tcellCounts = Nonogram.Utility.getZeroFilledArray( line.length );\r\n\r\n\t\t\t// keep two counts: 1) all common cells for this section, and 2) cells where no section can be\r\n\r\n\t\t\tfor (startIndexKey = 0; startIndexKey < section.possibleStartIndexes.length; startIndexKey++) {\r\n\r\n\t\t\t\tpossibleStartIndex = section.possibleStartIndexes[startIndexKey];\r\n\t\t\t\tstart              = possibleStartIndex;\r\n\t\t\t\tend                = start + section.length - 1;\r\n\r\n\t\t\t\tfor (i = start; i <= end; i++) {\r\n\t\t\t\t\tcellCounts[i]++;\r\n\t\t\t\t\ttotalCellCounts[i]++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\r\n\t\t\t// common to all possibilities, solve as positive\r\n\r\n\t\t\tfor (cellCountKey = 0; cellCountKey < cellCounts.length; cellCountKey++) {\r\n\r\n\t\t\t\tcellCount = cellCounts[cellCountKey];\r\n\t\t\t\tcell      = line.cells[cellCountKey];\r\n\r\n\t\t\t\tif (cell && cell.aiSolution === null && cellCount === section.possibleStartIndexes.length) {\r\n\t\t\t\t\tthis._setCellSolution( cell, 1 );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// no possible cells, remove as a possibility\r\n\r\n\t\tfor (cellCountKey = 0; cellCountKey < totalCellCounts.length; cellCountKey++) {\r\n\r\n\t\t\tcellCount = totalCellCounts[cellCountKey];\r\n\t\t\tcell      = line.cells[cellCountKey];\r\n\r\n\t\t\tif (cell && cell.aiSolution === null && cellCount === 0) {\r\n\t\t\t\tthis._setCellSolution( cell, 0 );\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t/**\r\n\t *\r\n\t * @param {Nonogram.PuzzleLine} line\r\n\t */\r\n\tfindAnchoredSections( line )\r\n\t{\r\n\t\tlet i, fillRange, firstSection, lastSection;\r\n\r\n\r\n\t\tif (line.sections.length > 0) {\r\n\r\n\t\t\tfirstSection = line.sections[0];\r\n\t\t\tlastSection  = line.sections[line.sections.length - 1];\r\n\r\n\t\t\t// find sections anchored to start of line\r\n\r\n\t\t\tfillRange = null;\r\n\r\n\t\t\tfor (i = 0; i < line.cells.length; i++) {\r\n\r\n\t\t\t\tif (line.cells[i].aiSolution === null) {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t} else if (line.cells[i].aiSolution === 1) {\r\n\t\t\t\t\tfillRange = [i, i + firstSection.length - 1];\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (fillRange !== null) {\r\n\r\n\t\t\t\tfor (i = fillRange[0]; i <= fillRange[1]; i++) {\r\n\t\t\t\t\tif (line.cells[i]) {\r\n\t\t\t\t\t\tthis._setCellSolution( line.cells[i], 1 );\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (line.cells[i]) {\r\n\t\t\t\t\tthis._setCellSolution( line.cells[i], 0 );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// find sections anchored to end of line\r\n\r\n\t\t\tfillRange = null;\r\n\r\n\t\t\tfor (i = line.cells.length - 1; i >= 0; i--) {\r\n\r\n\t\t\t\tif (line.cells[i].aiSolution === null) {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t} else if (line.cells[i].aiSolution === 1) {\r\n\t\t\t\t\tfillRange = [i - lastSection.length + 1, i];\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (fillRange !== null) {\r\n\r\n\t\t\t\tfor (i = fillRange[0]; i <= fillRange[1]; i++) {\r\n\t\t\t\t\tif (line.cells[i]) {\r\n\t\t\t\t\t\tthis._setCellSolution( line.cells[i], 1 );\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (line.cells[fillRange[0] - 1]) {\r\n\t\t\t\t\tthis._setCellSolution( line.cells[fillRange[0] - 1], 0 );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t/**\r\n\t *\r\n\t * @param {Nonogram.PuzzleLine} line\r\n\t */\r\n\tfindSectionDefiningChains( line )\r\n\t{\r\n\t\tlet chains    = [],\r\n\t\t\tlastValue = 0,\r\n\t\t\tcellKey, cell, chain, chainKey, sectionsSorted, firstSortedSection\r\n\t\t;\r\n\r\n\r\n\t\t// sort sections by highest length to lowest\r\n\r\n\t\tsectionsSorted     = Nonogram.Utility.cloneArray( line.sections ).sort( function ( a, b )\r\n\t\t{\r\n\t\t\treturn a.length > b.length ? -1 : 1;\r\n\t\t} );\r\n\t\tfirstSortedSection = sectionsSorted[0];\r\n\r\n\r\n\t\t// loop through all cells, creating array of connectors\r\n\r\n\t\tfor (cellKey = 0; cellKey < line.cells.length; cellKey++) {\r\n\r\n\t\t\tcell = line.cells[cellKey];\r\n\r\n\t\t\tif (cell.aiSolution === 1) {\r\n\r\n\t\t\t\tif (lastValue !== 1) {\r\n\t\t\t\t\tchain = {\r\n\t\t\t\t\t\tstart:  cellKey,\r\n\t\t\t\t\t\tlength: 1\r\n\t\t\t\t\t};\r\n\t\t\t\t\tchains.push( chain );\r\n\t\t\t\t} else {\r\n\t\t\t\t\tchain.length++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tlastValue = cell.aiSolution;\r\n\t\t}\r\n\r\n\r\n\t\t// if a connector is found with the first section's length, place negatives around it and mark the section as complete & continue\r\n\r\n\t\tfor (chainKey = 0; chainKey < chains.length; chainKey++) {\r\n\r\n\t\t\tchain = chains[chainKey];\r\n\r\n\t\t\tif (chain.length === firstSortedSection.length) {\r\n\r\n\t\t\t\tif (line.cells[chain.start - 1]) {\r\n\t\t\t\t\tthis._setCellSolution( line.cells[chain.start - 1], 0 );\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (line.cells[chain.start + firstSortedSection.length]) {\r\n\t\t\t\t\tthis._setCellSolution( line.cells[chain.start + firstSortedSection.length], 0 );\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfirstSortedSection.solved = true;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t/**\r\n\t *\r\n\t * @param {Nonogram.PuzzleLine} line\r\n\t */\r\n\tfindCompletedSections( line )\r\n\t{\r\n\t\tlet sectionKey, section, firstNegative, lastNegative;\r\n\r\n\t\t// complete lines where all sections have been found\r\n\r\n\t\tfor (sectionKey = 0; sectionKey < line.sections.length; sectionKey++) {\r\n\r\n\t\t\tsection = line.sections[sectionKey];\r\n\r\n\r\n\t\t\t// only one possible place...\r\n\r\n\t\t\tif (!section.solved && section.possibleStartIndexes.length === 1) {\r\n\r\n\t\t\t\t// make sure there is a negative cell on either side of the section\r\n\r\n\t\t\t\tfirstNegative = section.possibleStartIndexes[0] - 1;\r\n\t\t\t\tlastNegative  = section.possibleStartIndexes[0] + section.length;\r\n\r\n\t\t\t\tif (line.cells[firstNegative] && line.cells[firstNegative].aiSolution === null) {\r\n\t\t\t\t\tthis._setCellSolution( line.cells[firstNegative], 0 );\r\n\t\t\t\t}\r\n\t\t\t\tif (line.cells[lastNegative] && line.cells[lastNegative].aiSolution === null) {\r\n\t\t\t\t\tthis._setCellSolution( line.cells[lastNegative], 0 );\r\n\t\t\t\t}\r\n\r\n\t\t\t\tsection.solved = true;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t/**\r\n\t *\r\n\t * @param {Nonogram.PuzzleLine} line\r\n\t */\r\n\tfindCompletedLines( line )\r\n\t{\r\n\t\tlet totalSectionLength  = 0,\r\n\t\t\ttotalPositiveSolved = 0,\r\n\t\t\tsectionKey, section, cellKey, cell\r\n\t\t;\r\n\r\n\t\t// complete lines where all sections have been found\r\n\r\n\t\tfor (sectionKey = 0; sectionKey < line.sections.length; sectionKey++) {\r\n\r\n\t\t\tsection = line.sections[sectionKey];\r\n\t\t\ttotalSectionLength += section.length;\r\n\t\t}\r\n\r\n\t\tfor (cellKey = 0; cellKey < line.cells.length; cellKey++) {\r\n\r\n\t\t\tcell = line.cells[cellKey];\r\n\t\t\ttotalPositiveSolved += cell.aiSolution === 1;\r\n\t\t}\r\n\r\n\t\tif (totalSectionLength === totalPositiveSolved) {\r\n\r\n\t\t\tfor (cellKey = 0; cellKey < line.cells.length; cellKey++) {\r\n\r\n\t\t\t\tcell = line.cells[cellKey];\r\n\r\n\t\t\t\tif (cell.aiSolution === null) {\r\n\t\t\t\t\tthis._setCellSolution( cell, 0 );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t//\t#############################################################################################\tprivate methods\r\n\r\n\r\n\t/**\r\n\t *\r\n\t * @private\r\n\t */\r\n\t_reset()\r\n\t{\r\n\t\tconst possibleRowIndexes    = [],\r\n\t\t\t  possibleColumnIndexes = []\r\n\t\t;\r\n\t\tlet i, cellKey, rowNumber, rowHints, rowCells, line, index, len, columnKey, columnHint;\r\n\r\n\t\tthis.isReset     = true;\r\n\t\tthis.elapsedTime = 0;\r\n\t\tthis.solutionLog = [];\r\n\t\tthis.lines       = [];\r\n\r\n\t\tthis._log( 'Resetting variables', 'info' );\r\n\r\n\t\t// reset cell.aiSolution\r\n\r\n\t\tfor (cellKey = 0; cellKey < this.puzzle.cells.length; cellKey++) {\r\n\t\t\tthis.puzzle.cells[cellKey].aiSolution = null;\r\n\t\t}\r\n\r\n\t\t// reset possibleRowIndexes\r\n\r\n\t\tfor (i = 0; i < this.puzzle.width; i++) {\r\n\t\t\tpossibleRowIndexes.push( i );\r\n\t\t}\r\n\r\n\t\t// reset possibleColumnIndexes\r\n\r\n\t\tfor (i = 0; i < this.puzzle.height; i++) {\r\n\t\t\tpossibleColumnIndexes.push( i );\r\n\t\t}\r\n\r\n\t\t// reset rowHints\r\n\r\n\t\tfor (rowNumber = 0; rowNumber < this.puzzle.rowHints.length; rowNumber++) {\r\n\r\n\t\t\trowHints = this.puzzle.rowHints[rowNumber];\r\n\t\t\trowCells = this.puzzle.getRowCells( rowNumber );\r\n\r\n\t\t\tif (rowCells) {\r\n\r\n\t\t\t\tline = new Nonogram.PuzzleLine( {\r\n\t\t\t\t\ttype:   'row',\r\n\t\t\t\t\tindex:  rowNumber,\r\n\t\t\t\t\tlength: this.puzzle.width,\r\n\t\t\t\t\tcells:  rowCells\r\n\t\t\t\t} );\r\n\r\n\t\t\t\tfor (index = 0; index < rowHints.length; index++) {\r\n\r\n\t\t\t\t\tlen = rowHints[index];\r\n\t\t\t\t\tline.sections.push( {\r\n\t\t\t\t\t\tindex:                index,\r\n\t\t\t\t\t\tlength:               len,\r\n\t\t\t\t\t\tpossibleStartIndexes: possibleRowIndexes,\r\n\t\t\t\t\t\tknownIndexes:         [],\r\n\t\t\t\t\t\tsolved:               false\r\n\t\t\t\t\t} );\r\n\r\n\t\t\t\t\tline.minimumSectionLength += len + 1;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tline.minimumSectionLength--;\r\n\r\n\t\t\t\tthis.lines.push( line );\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// reset columnHints\r\n\r\n\t\tfor (columnKey = 0; columnKey < this.puzzle.columnHints.length; columnKey++) {\r\n\r\n\t\t\tcolumnHint = this.puzzle.columnHints[columnKey];\r\n\t\t\tline       = new Nonogram.PuzzleLine( {\r\n\t\t\t\ttype:   'column',\r\n\t\t\t\tindex:  columnKey,\r\n\t\t\t\tlength: this.puzzle.height,\r\n\t\t\t\tcells:  this.puzzle.getColumnCells( columnKey ),\r\n\t\t\t} );\r\n\r\n\t\t\tfor (index = 0; index < columnHint.length; index++) {\r\n\t\t\t\tlen = columnHint[index];\r\n\t\t\t\tline.sections.push( {\r\n\t\t\t\t\tindex:                index,\r\n\t\t\t\t\tlength:               len,\r\n\t\t\t\t\tpossibleStartIndexes: possibleColumnIndexes,\r\n\t\t\t\t\tknownIndexes:         [],\r\n\t\t\t\t\tsolved:               false\r\n\t\t\t\t} );\r\n\r\n\t\t\t\tline.minimumSectionLength += len + 1;\r\n\t\t\t}\r\n\r\n\t\t\tline.minimumSectionLength--;\r\n\r\n\t\t\tthis.lines.push( line );\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t/**\r\n\t *\r\n\t * @param {Nonogram.PuzzleCell} puzzleCell\r\n\t * @param {number} value\r\n\t * @private\r\n\t */\r\n\t_setCellSolution( puzzleCell, value )\r\n\t{\r\n\t\tlet lineKey, line, isRow, isCol, cellsSolved, cellKey, cell;\r\n\r\n\t\tif (puzzleCell.aiSolution !== null) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tfor (lineKey = 0; lineKey < this.lines.length; lineKey++) {\r\n\r\n\t\t\tline        = this.lines[lineKey];\r\n\t\t\tisRow       = line.type === 'row' && line.index === puzzleCell.row;\r\n\t\t\tisCol       = line.type === 'column' && line.index === puzzleCell.column;\r\n\t\t\tcellsSolved = 0;\r\n\r\n\t\t\tif (isRow || isCol) {\r\n\r\n\t\t\t\tfor (cellKey = 0; cellKey < line.cells.length; cellKey++) {\r\n\r\n\t\t\t\t\tcell = line.cells[cellKey];\r\n\r\n\t\t\t\t\tif (cell.index === puzzleCell.index) {\r\n\t\t\t\t\t\tcell.aiSolution = value;\r\n\t\t\t\t\t\tcellsSolved++;\r\n\t\t\t\t\t} else if (cell.aiSolution !== null) {\r\n\t\t\t\t\t\tcellsSolved++;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (cellsSolved === line.length) {\r\n\t\t\t\t\tline.solved = true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t/**\r\n\t *\r\n\t * @param html\r\n\t * @param cssClass\r\n\t * @private\r\n\t */\r\n\t_log( html, cssClass )\r\n\t{\r\n\t\tthis.solutionLog.push( {\r\n\t\t\thtml:     html,\r\n\t\t\tcssClass: cssClass || 'info'\r\n\t\t} );\r\n\t}\r\n\r\n\r\n\t/**\r\n\t *\r\n\t * @returns {number}\r\n\t * @private\r\n\t */\r\n\t_getTotalSolved()\r\n\t{\r\n\t\tlet total = 0,\r\n\t\t\tcellKey\r\n\t\t;\r\n\r\n\t\tfor (cellKey = 0; cellKey < this.puzzle.cells.length; cellKey++) {\r\n\t\t\ttotal += this.puzzle.cells[cellKey].aiSolution !== null;\r\n\t\t}\r\n\r\n\t\treturn total;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * calculate the maximum # of possible permutations, depending on the current state of the solving process.\r\n\t *\r\n\t * @returns {number}\r\n\t * @private\r\n\t */\r\n\t_getProgress()\r\n\t{\r\n\t\tlet maxPossibilities   = 0,\r\n\t\t\ttotalPossibilities = 0,\r\n\t\t\tlineKey, line, sectionKey\r\n\t\t;\r\n\r\n\t\tfor (lineKey = 0; lineKey < this.lines.length; lineKey++) {\r\n\r\n\t\t\tline = this.lines[lineKey];\r\n\t\t\tmaxPossibilities += line.sections.length * (line.type === 'row' ? this.puzzle.width : this.puzzle.height);\r\n\r\n\t\t\tfor (sectionKey = 0; sectionKey < line.sections.length; sectionKey++) {\r\n\t\t\t\ttotalPossibilities += line.sections[sectionKey].possibleStartIndexes.length;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn maxPossibilities - totalPossibilities;\r\n\t}\r\n\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n","import Nonogram from './nonogram';\r\n\r\n\r\n/**\r\n * @class\r\n * @type {Nonogram.Gui}\r\n * @this Nonogram.Gui\r\n *\r\n * provides a user interface for interacting with nonogram puzzles\r\n *\r\n * @property {Nonogram.Puzzle} puzzle\r\n * @property {HTMLElement} gridContainer - container element for the puzzle grid ui\r\n * @property {array} templates - array of Nonogram.GuiTemplate objects\r\n * @property {array} templatesLoaded - array of Promises from each onLoad template\r\n * @property {string|null} theme - the theme to use, located in the themes/ directory\r\n * @property {string} themePath - the path to the specified theme located in themes/{theme}\r\n * @property {string} themeStylesheetPath - the path to the theme stylesheet located in themes/{theme}/styles.css\r\n * @property {string} themeTemplatesPath - the path to the theme template directory located in themes/{theme}/templates\r\n * @property {int} playerClickMode - whether to fill or cross a cell on click\r\n */\r\nNonogram.Gui = class\r\n{\r\n\r\n\t/**\r\n\t *\r\n\t * @param {string|null} theme - the theme to use, located in the themes/ directory\r\n\t */\r\n\tconstructor( theme )\r\n\t{\r\n\t\tconst head = document.querySelector( 'head' ),\r\n\t\t\t  link = document.createElement( 'link' )\r\n\t\t;\r\n\r\n\t\t// set up board sizes\r\n\t\tthis.boardSizes = [\r\n\t\t\t{ name: 'Tiny', handle: 'tiny', size: 1 },\r\n\t\t\t{ name: 'Small', handle: 'small', size: 2 },\r\n\t\t\t{ name: 'Medium', handle: 'medium', size: 3 },\r\n\t\t\t{ name: 'Large', handle: 'large', size: 4 },\r\n\t\t];\r\n\t\tthis.boardSize  = this.boardSizes[2];\r\n\r\n\t\t// set up theme\r\n\t\tthis.theme     = theme || 'default';\r\n\t\tthis.themePath = this._resolveThemePath() + '/' + this.theme;\r\n\r\n\t\t// load theme stylesheet\r\n\t\tthis.themeStylesheetPath = this.themePath + '/styles.css';\r\n\t\tlink.rel                 = 'stylesheet';\r\n\t\tlink.type                = 'text/css';\r\n\t\tlink.href                = this.themeStylesheetPath;\r\n\t\thead.prepend( link );\r\n\r\n\t\t// set up templates\r\n\t\tthis.templatesLoaded    = [];\r\n\t\tthis.themeTemplatesPath = this.themePath + '/templates';\r\n\t\tthis.templates          = [\r\n\t\t\tnew Nonogram.GuiTemplate( 'gameControls', this.themeTemplatesPath + '/controls-game.html' ),\r\n\t\t\tnew Nonogram.GuiTemplate( 'generateControls', this.themeTemplatesPath + '/controls-generate.html' ),\r\n\t\t\tnew Nonogram.GuiTemplate( 'console', this.themeTemplatesPath + '/console.html' ),\r\n\t\t\tnew Nonogram.GuiTemplate( 'previewGrid', this.themeTemplatesPath + '/preview-grid.html' ),\r\n\t\t\tnew Nonogram.GuiTemplate( 'puzzleGrid', this.themeTemplatesPath + '/puzzle-grid.html' ),\r\n\t\t];\r\n\r\n\t\t// load templates\r\n\t\tthis.templates.forEach( ( template ) =>\r\n\t\t{\r\n\t\t\tthis.templatesLoaded.push(\r\n\t\t\t\ttemplate.load()\r\n\t\t\t);\r\n\t\t} );\r\n\t}\r\n\r\n\r\n\t// ######################################################################################\tpublic drawing methods\r\n\r\n\t/**\r\n\t * - draw all user interfaces once templates are onLoad\r\n\t */\r\n\tdraw( puzzle )\r\n\t{\r\n\t\tthis.puzzle = puzzle;\r\n\r\n\t\tPromise.all( this.templatesLoaded ).then( () =>\r\n\t\t{\r\n\t\t\tthis.drawGenerateControls();\r\n\t\t\tthis.drawPuzzle( puzzle );\r\n\t\t\tthis.drawGameControls();\r\n\t\t\tthis.drawConsole();\r\n\t\t} );\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * - draw the puzzle ui\r\n\t *\r\n\t * @param {Nonogram.Puzzle} puzzle\r\n\t */\r\n\tdrawPuzzle( puzzle )\r\n\t{\r\n\t\tPromise.all( this.templatesLoaded ).then( () =>\r\n\t\t{\r\n\t\t\tconst template = this._getTemplate( 'puzzleGrid' );\r\n\r\n\t\t\tthis.puzzle        = puzzle;\r\n\t\t\tthis.gridContainer = document.querySelector( '[data-nonogram-puzzle-grid]' );\r\n\r\n\r\n\t\t\tif (!this.gridContainer) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tconst container       = this.gridContainer,\r\n\t\t\t\t  node            = template.getNode(),\r\n\t\t\t\t  theadThTemplate = node.querySelector( '[data-nonogram-puzzle-grid-table-thead-th]' ),\r\n\t\t\t\t  rowTemplate     = node.querySelector( '[data-nonogram-puzzle-grid-table-row]' ),\r\n\t\t\t\t  cellClasses     = {\r\n\t\t\t\t\t  tl: 0,\r\n\t\t\t\t\t  tr: this.puzzle.width - 1,\r\n\t\t\t\t\t  bl: (this.puzzle.width * this.puzzle.height) - this.puzzle.width,\r\n\t\t\t\t\t  br: (this.puzzle.width * this.puzzle.height) - 1,\r\n\t\t\t\t  }\r\n\t\t\t;\r\n\r\n\t\t\t// table header\r\n\t\t\tthis.puzzle.columnHints.forEach( ( hints, columnIndex ) =>\r\n\t\t\t{\r\n\t\t\t\tconst clonedTheadThTemplate = document.importNode( theadThTemplate.content, true ),\r\n\t\t\t\t\t  theadTh               = clonedTheadThTemplate.querySelector( 'th' ),\r\n\t\t\t\t\t  fillDiv               = theadTh.querySelector( '.fill' );\r\n\r\n\t\t\t\ttheadTh.setAttribute( 'data-column', columnIndex.toString() );\r\n\t\t\t\ttheadTh.classList.add( 'hint', 'top' );\r\n\r\n\t\t\t\t// add hints\r\n\t\t\t\thints.forEach( ( hint ) =>\r\n\t\t\t\t{\r\n\t\t\t\t\tlet span = document.createElement( 'span' );\r\n\r\n\t\t\t\t\tspan.textContent = hint;\r\n\t\t\t\t\tfillDiv.appendChild( span );\r\n\t\t\t\t} );\r\n\r\n\t\t\t\ttheadThTemplate.parentNode.insertBefore( theadTh, theadThTemplate );\r\n\t\t\t} );\r\n\r\n\r\n\t\t\t// table rows\r\n\r\n\t\t\tthis.puzzle.grid.forEach( ( row, rowKey ) =>\r\n\t\t\t{\r\n\t\t\t\tconst cells             = this.puzzle.getRowCells( rowKey ),\r\n\t\t\t\t\t  clonedRowTemplate = document.importNode( rowTemplate.content, true ),\r\n\t\t\t\t\t  tr                = clonedRowTemplate.querySelector( 'tr' ),\r\n\t\t\t\t\t  cellTemplate      = tr.querySelector( '[data-nonogram-puzzle-grid-table-cell]' ),\r\n\t\t\t\t\t  hintsFillDiv      = tr.querySelector( '[data-row-hints] .fill' )\r\n\t\t\t\t;\r\n\r\n\t\t\t\ttr.setAttribute( 'data-row', rowKey.toString() );\r\n\r\n\t\t\t\t// hint cell\r\n\t\t\t\tthis.puzzle.rowHints[rowKey].forEach( ( hint ) =>\r\n\t\t\t\t{\r\n\t\t\t\t\tlet span = document.createElement( 'span' );\r\n\r\n\t\t\t\t\tspan.textContent = hint;\r\n\t\t\t\t\thintsFillDiv.appendChild( span );\r\n\t\t\t\t} );\r\n\r\n\t\t\t\t// grid cells\r\n\t\t\t\tcells.forEach( ( cell ) =>\r\n\t\t\t\t{\r\n\t\t\t\t\tconst clonedCellTemplate = document.importNode( cellTemplate.content, true ),\r\n\t\t\t\t\t\t  td                 = clonedCellTemplate.querySelector( 'td' )\r\n\t\t\t\t\t;\r\n\r\n\t\t\t\t\ttd.setAttribute( 'data-index', cell.index );\r\n\t\t\t\t\ttd.setAttribute( 'data-column', cell.column );\r\n\t\t\t\t\ttd.setAttribute( 'data-row', cell.row );\r\n\t\t\t\t\ttd.classList.add( 'puzzle-cell', 'flippable' );\r\n\r\n\t\t\t\t\tObject.keys( cellClasses ).forEach( ( cssClass ) =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif (cell.index === cellClasses[cssClass]) {\r\n\t\t\t\t\t\t\ttd.classList.add( cssClass );\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} );\r\n\r\n\t\t\t\t\ttr.appendChild( td );\r\n\t\t\t\t} );\r\n\r\n\t\t\t\trowTemplate.parentNode.appendChild( tr );\r\n\t\t\t} );\r\n\r\n\r\n\t\t\t// insert template\r\n\t\t\tcontainer.innerHtml = container.textContent = '';\r\n\t\t\tcontainer.appendChild( node );\r\n\r\n\t\t\t// set board size\r\n\t\t\tdocument.querySelector( '[data-nonogram-puzzle-grid-table]' ).classList.add( this.boardSize.handle );\r\n\r\n\t\t\tthis._resizeBoardForAvailableScreen();\r\n\t\t\tthis._makePuzzlePlayable();\r\n\t\t\tthis.drawPreview( 'userSolution' );\r\n\t\t} );\r\n\t}\r\n\r\n\r\n\t/**\r\n\t *    - draw the game controls ui\r\n\t */\r\n\tdrawGameControls()\r\n\t{\r\n\t\tPromise.all( this.templatesLoaded ).then( () =>\r\n\t\t{\r\n\t\t\tconst template  = this._getTemplate( 'gameControls' ),\r\n\t\t\t\t  container = document.querySelector( '[data-nonogram-game-controls]' ),\r\n\t\t\t\t  node      = template.getNode()\r\n\t\t\t;\r\n\t\t\tlet fillModeCheckbox;\r\n\r\n\r\n\t\t\tif (!container) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\t// insert template\r\n\t\t\tcontainer.innerHtml = container.textContent = '';\r\n\t\t\tcontainer.appendChild( node );\r\n\r\n\t\t\t// add event handlers\r\n\t\t\tfillModeCheckbox = document.querySelector( '#nonogram-puzzle-fill-mode' );\r\n\r\n\t\t\tfillModeCheckbox.addEventListener( 'change', () =>\r\n\t\t\t{\r\n\t\t\t\tconst fillModeLabel = document.querySelector( '[for=\"nonogram-puzzle-fill-mode\"]' ),\r\n\t\t\t\t\t  prevActive    = fillModeLabel.querySelector( '.active' ),\r\n\t\t\t\t\t  prevInactive  = fillModeLabel.querySelector( '.inactive' )\r\n\t\t\t\t;\r\n\r\n\t\t\t\tprevActive.classList.remove( 'active' );\r\n\t\t\t\tprevActive.classList.add( 'inactive' );\r\n\t\t\t\tprevInactive.classList.remove( 'inactive' );\r\n\t\t\t\tprevInactive.classList.add( 'active' );\r\n\r\n\t\t\t\tif (fillModeCheckbox.checked) {\r\n\t\t\t\t\tfillModeLabel.classList.add( 'on' );\r\n\t\t\t\t\tthis.playerClickMode = 0;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tfillModeLabel.classList.remove( 'on' );\r\n\t\t\t\t\tthis.playerClickMode = 1;\r\n\t\t\t\t}\r\n\t\t\t} );\r\n\r\n\t\t\twindow.addEventListener( 'keyup', ( e ) =>\r\n\t\t\t{\r\n\t\t\t\tif (e.key && e.key === 'x') {\r\n\t\t\t\t\tfillModeCheckbox.dispatchEvent( new MouseEvent( 'click' ) );\r\n\t\t\t\t}\r\n\t\t\t} );\r\n\t\t} );\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * - draw puzzle generating/solving/resetting ui\r\n\t */\r\n\tdrawGenerateControls()\r\n\t{\r\n\t\tPromise.all( this.templatesLoaded ).then( () =>\r\n\t\t{\r\n\t\t\tconst template            = this._getTemplate( 'generateControls' ),\r\n\t\t\t\t  container           = document.querySelector( '[data-nonogram-generate-controls]' ),\r\n\t\t\t\t  node                = template.getNode(),\r\n\t\t\t\t  widthSelect         = node.querySelector( '[data-nonogram-generate-width]' ),\r\n\t\t\t\t  heightSelect        = node.querySelector( '[data-nonogram-generate-height]' ),\r\n\t\t\t\t  widthOptions        = node.querySelector( '[data-nonogram-generate-width-options]' ),\r\n\t\t\t\t  heightOptions       = node.querySelector( '[data-nonogram-generate-height-options]' ),\r\n\t\t\t\t  chooseExampleSelect = node.querySelector( '[data-nonogram-choose-predefined]' ),\r\n\t\t\t\t  boardSizeSelect     = node.querySelector( '[data-nonogram-board-size]' ),\r\n\t\t\t\t  boardSizeOptions    = node.querySelector( '[data-nonogram-board-size-options]' )\r\n\t\t\t;\r\n\t\t\tlet i, clonedWidthOptions, cloneHeightOptions, widthOption, heightOption, clonedExampleOptions,\r\n\t\t\t\texampleOption, chooseSelect, boardSize, clonedSizeOptions, sizeOption, reset, solve, generate;\r\n\r\n\r\n\t\t\tif (!container) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\t// populate width/height select elements\r\n\t\t\tfor (i = 5; i <= 30; i++) {\r\n\r\n\t\t\t\tclonedWidthOptions       = document.importNode( widthOptions.content, true );\r\n\t\t\t\tcloneHeightOptions       = document.importNode( heightOptions.content, true );\r\n\t\t\t\twidthOption              = clonedWidthOptions.querySelector( 'option' );\r\n\t\t\t\twidthOption.textContent  = widthOption.value = i;\r\n\t\t\t\theightOption             = cloneHeightOptions.querySelector( 'option' );\r\n\t\t\t\theightOption.textContent = heightOption.value = i;\r\n\r\n\t\t\t\tif (this.puzzle.width === i) {\r\n\t\t\t\t\twidthOption.setAttribute( 'selected', 'selected' );\r\n\t\t\t\t}\r\n\t\t\t\tif (this.puzzle.height === i) {\r\n\t\t\t\t\theightOption.setAttribute( 'selected', 'selected' );\r\n\t\t\t\t}\r\n\r\n\t\t\t\twidthSelect.appendChild( widthOption );\r\n\t\t\t\theightSelect.appendChild( heightOption );\r\n\t\t\t}\r\n\r\n\t\t\t// populate predefined puzzles\r\n\r\n\t\t\tObject.keys( Nonogram.PuzzleLibrary ).forEach( ( puzzleName ) =>\r\n\t\t\t{\r\n\t\t\t\tclonedExampleOptions = document.importNode( widthOptions.content, true );\r\n\t\t\t\texampleOption        = clonedExampleOptions.querySelector( 'option' );\r\n\r\n\t\t\t\texampleOption.textContent = exampleOption.value = puzzleName;\r\n\r\n\t\t\t\tif (puzzleName === this.selectedExample) {\r\n\t\t\t\t\texampleOption.setAttribute( 'selected', 'selected' );\r\n\t\t\t\t}\r\n\r\n\t\t\t\tchooseExampleSelect.appendChild( exampleOption );\r\n\t\t\t} );\r\n\r\n\t\t\t// populate board size\r\n\t\t\tthis.boardSizes.forEach( ( sizeObj ) =>\r\n\t\t\t{\r\n\t\t\t\tclonedSizeOptions = document.importNode( boardSizeOptions.content, true );\r\n\t\t\t\tsizeOption        = clonedSizeOptions.querySelector( 'option' );\r\n\r\n\t\t\t\tsizeOption.value       = sizeObj.handle;\r\n\t\t\t\tsizeOption.textContent = sizeObj.name;\r\n\r\n\r\n\t\t\t\tif (sizeObj.handle === this.boardSize.handle) {\r\n\t\t\t\t\tsizeOption.setAttribute( 'selected', 'selected' );\r\n\t\t\t\t}\r\n\r\n\t\t\t\tboardSizeSelect.appendChild( sizeOption );\r\n\t\t\t} );\r\n\r\n\t\t\t// insert template\r\n\t\t\tcontainer.innerHtml = container.textContent = '';\r\n\t\t\tcontainer.appendChild( node );\r\n\r\n\t\t\t// add event handlers\r\n\t\t\tgenerate     = document.querySelector( '[data-nonogram-generate-button]' );\r\n\t\t\tchooseSelect = document.querySelector( '[data-nonogram-choose-predefined]' );\r\n\t\t\tboardSize    = document.querySelector( '[data-nonogram-board-size]' );\r\n\t\t\treset        = document.querySelector( '[data-nonogram-game-reset]' );\r\n\t\t\tsolve        = document.querySelector( '[data-nonogram-game-solve]' );\r\n\r\n\t\t\tgenerate.addEventListener( 'click', () =>\r\n\t\t\t{\r\n\t\t\t\tconst widthSelect    = document.querySelector( '[data-nonogram-generate-width]' ),\r\n\t\t\t\t\t  heightSelect   = document.querySelector( '[data-nonogram-generate-height]' ),\r\n\t\t\t\t\t  width          = widthSelect.value,\r\n\t\t\t\t\t  height         = heightSelect.value,\r\n\t\t\t\t\t  creator        = new Nonogram.Creator(),\r\n\t\t\t\t\t  puzzle         = creator.createRandom( width, height, null )\r\n\t\t\t\t;\r\n\t\t\t\tthis.selectedExample = null;\r\n\t\t\t\tthis.draw( puzzle );\r\n\t\t\t\tthis._resizeBoardForAvailableScreen();\r\n\t\t\t} );\r\n\r\n\t\t\tchooseSelect.addEventListener( 'change', () =>\r\n\t\t\t{\r\n\t\t\t\tconst creator = new Nonogram.Creator();\r\n\t\t\t\tlet puzzleDef, puzzle;\r\n\r\n\t\t\t\tif (chooseSelect.value !== '') {\r\n\t\t\t\t\tObject.keys( Nonogram.PuzzleLibrary ).forEach( ( puzzleName ) =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif (chooseSelect.value === puzzleName) {\r\n\r\n\t\t\t\t\t\t\tpuzzleDef            = Nonogram.PuzzleLibrary[puzzleName];\r\n\t\t\t\t\t\t\tthis.selectedExample = puzzleName;\r\n\r\n\t\t\t\t\t\t\tif (puzzleDef.solutionGrid) {\r\n\t\t\t\t\t\t\t\tpuzzle = creator.createFromGrid( puzzleDef.solutionGrid );\r\n\t\t\t\t\t\t\t} else if (puzzleDef.hints) {\r\n\t\t\t\t\t\t\t\tpuzzle = creator.createFromHints( puzzleDef.hints );\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} );\r\n\r\n\t\t\t\t\tif (puzzle) {\r\n\t\t\t\t\t\tthis.draw( puzzle );\r\n\t\t\t\t\t\tthis._resizeBoardForAvailableScreen();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} );\r\n\r\n\t\t\tboardSize.addEventListener( 'change', () =>\r\n\t\t\t{\r\n\t\t\t\tthis.boardSizes.forEach( ( item ) =>\r\n\t\t\t\t{\r\n\t\t\t\t\tif (item.handle === boardSize.value) {\r\n\t\t\t\t\t\tthis._changeBoardSize( item );\r\n\t\t\t\t\t}\r\n\t\t\t\t} );\r\n\t\t\t} );\r\n\r\n\t\t\treset.addEventListener( 'click', () =>\r\n\t\t\t{\r\n\t\t\t\tthis._resetPuzzle();\r\n\t\t\t} );\r\n\r\n\t\t\tsolve.addEventListener( 'click', () =>\r\n\t\t\t{\r\n\t\t\t\t// TODO: uncomment confirm ?\r\n\r\n\t\t\t\t//if (confirm( 'Are you sure you want to see the answer?' )) {\r\n\t\t\t\tthis.drawSolution();\r\n\t\t\t\tthis.drawPreview( 'solution' );\r\n\t\t\t\tthis._showPuzzleSolved();\r\n\t\t\t\t//}\r\n\t\t\t} );\r\n\t\t} );\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * - draw the console and populate with Nonogram.Creator _log\r\n\t */\r\n\tdrawConsole()\r\n\t{\r\n\t\tPromise.all( this.templatesLoaded ).then( () =>\r\n\t\t{\r\n\t\t\tconst template  = this._getTemplate( 'console' ),\r\n\t\t\t\t  container = document.querySelector( '[data-nonogram-console]' ),\r\n\t\t\t\t  node      = template.getNode(),\r\n\t\t\t\t  output    = node.querySelector( '[data-nonogram-console-output]' ),\r\n\t\t\t\t  line      = node.querySelector( '[data-nonogram-console-line]' )\r\n\t\t\t;\r\n\r\n\t\t\tif (!container) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tif (this.puzzle.creator instanceof Nonogram.Creator) {\r\n\t\t\t\tthis.puzzle.creator.log.forEach( ( text ) =>\r\n\t\t\t\t{\r\n\t\t\t\t\tconst clonedLine = document.importNode( line.content, true ),\r\n\t\t\t\t\t\t  code       = clonedLine.querySelector( 'code' );\r\n\r\n\t\t\t\t\tcode.textContent = text.toString();\r\n\t\t\t\t\toutput.appendChild( code );\r\n\t\t\t\t} );\r\n\t\t\t}\r\n\r\n\t\t\t// insert template\r\n\t\t\tcontainer.innerHtml = container.textContent = '';\r\n\t\t\tcontainer.appendChild( node );\r\n\t\t} );\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * - draw the preview grid for the current state of the puzzle\r\n\t *\r\n\t * @param solutionType\r\n\t */\r\n\tdrawPreview( solutionType )\r\n\t{\r\n\t\tPromise.all( this.templatesLoaded ).then( () =>\r\n\t\t{\r\n\t\t\tconst template  = this._getTemplate( 'previewGrid' ),\r\n\t\t\t\t  container = document.querySelector( '[data-nonogram-preview-grid]' ),\r\n\t\t\t\t  node      = template.getNode()\r\n\t\t\t;\r\n\r\n\t\t\t// insert template\r\n\r\n\t\t\tcontainer.innerHtml = container.textContent = '';\r\n\t\t\tcontainer.appendChild( node.querySelector( '[data-nonogram-preview]' ) );\r\n\r\n\r\n\t\t\t// draw preview canvas\r\n\r\n\t\t\tconst canvas          = document.querySelector( '[data-nonogram-preview-canvas]' ),\r\n\t\t\t\t  ctx             = canvas.getContext( '2d' ),\r\n\t\t\t\t  parentContainer = canvas.parentElement.parentElement.parentElement,\r\n\t\t\t\t  parentWidth     = parentContainer.offsetWidth,\r\n\t\t\t\t  parentHeight    = parentContainer.offsetHeight,\r\n\t\t\t\t  containerRatio  = parentWidth / parentHeight,\r\n\t\t\t\t  puzzleRatio     = this.puzzle.width / this.puzzle.height\r\n\t\t\t;\r\n\t\t\tlet cellSize;\r\n\r\n\t\t\tif (containerRatio > puzzleRatio) {\r\n\t\t\t\tcellSize = Math.floor( parentHeight / this.puzzle.height );\r\n\t\t\t} else {\r\n\t\t\t\tcellSize = Math.floor( parentWidth / this.puzzle.width );\r\n\t\t\t}\r\n\r\n\t\t\tcanvas.width  = cellSize * this.puzzle.width;\r\n\t\t\tcanvas.height = cellSize * this.puzzle.height;\r\n\r\n\t\t\tthis.puzzle.cells.forEach( ( cell ) =>\r\n\t\t\t{\r\n\t\t\t\tif (cell[solutionType] === 1) {\r\n\t\t\t\t\tctx.fillRect( cell.column * cellSize, cell.row * cellSize, cellSize, cellSize );\r\n\t\t\t\t}\r\n\t\t\t} );\r\n\t\t} );\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * - draw the solution to the current puzzle\r\n\t */\r\n\tdrawSolution()\r\n\t{\r\n\t\tPromise.all( this.templatesLoaded ).then( () =>\r\n\t\t{\r\n\t\t\tconst filledTds = this.gridContainer.querySelectorAll( 'td.filled' );\r\n\r\n\r\n\t\t\tfilledTds.forEach( ( td ) =>\r\n\t\t\t{\r\n\t\t\t\ttd.classList.remove( 'filled', 'solution-positive', 'solution-negative', 'user-positive', 'user-negative', 'flipped' );\r\n\t\t\t} );\r\n\r\n\t\t\tthis.puzzle.cells.forEach( ( cell ) =>\r\n\t\t\t{\r\n\t\t\t\tconst cellElem = this.gridContainer.querySelector( 'td[data-index=\"' + cell.index + '\"]' );\r\n\r\n\t\t\t\tcell.userSolution = cell.solution;\r\n\t\t\t\tcellElem.classList.add( 'user-solved' );\r\n\r\n\t\t\t\tif (cell.solution === 1) {\r\n\t\t\t\t\tcellElem.classList.add( 'solution-positive', 'user-positive', 'flipped' );\r\n\t\t\t\t} else {\r\n\t\t\t\t\tcellElem.classList.add( 'solution-negative', 'user-negative' );\r\n\t\t\t\t}\r\n\t\t\t} );\r\n\t\t} );\r\n\t}\r\n\r\n\r\n\t// ######################################################################################\tprivate methods\r\n\r\n\r\n\t/**\r\n\t *\r\n\t * @param {object} boardSize\r\n\t * @private\r\n\t */\r\n\t_changeBoardSize( boardSize )\r\n\t{\r\n\t\tconst puzzleTable = document.querySelector( '[data-nonogram-puzzle-grid-table]' ),\r\n\t\t\t  sizeSelect  = document.querySelector( '[data-nonogram-board-size]' )\r\n\t\t;\r\n\r\n\t\tif (puzzleTable && sizeSelect) {\r\n\r\n\t\t\tpuzzleTable.classList.remove( 'tiny', 'small', 'medium', 'large' );\r\n\t\t\tpuzzleTable.classList.add( boardSize.handle );\r\n\t\t\tsizeSelect.value = boardSize.handle;\r\n\r\n\t\t\tthis.boardSize = boardSize;\r\n\r\n\t\t\tthis.drawPreview();\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t/**\r\n\t *\r\n\t * @private\r\n\t */\r\n\t_resizeBoardForAvailableScreen()\r\n\t{\r\n\t\tconst table            = this.gridContainer.querySelector( '.nonogram-puzzle-grid' ),\r\n\t\t\t  availableWidth   = this.gridContainer.clientWidth,\r\n\t\t\t  sortedBoardSizes = this.boardSizes.sort( ( a, b ) =>\r\n\t\t\t  {\r\n\t\t\t\t  return a.size > b.size ? -1 : 1;\r\n\t\t\t  } )\r\n\t\t;\r\n\t\tlet i;\r\n\r\n\r\n\t\t//if (this.puzzle.creator) {\r\n\t\t//this.puzzle.creator.log.push( 'tableWidth: ' + table.clientWidth + ', availableWidth: ' + availableWidth );\r\n\t\t//}\r\n\r\n\t\tif (table.clientWidth > availableWidth) {\r\n\r\n\t\t\tfor (i = 0; i < sortedBoardSizes.length; i++) {\r\n\r\n\t\t\t\tif (sortedBoardSizes[i].size < this.boardSize.size) {\r\n\r\n\t\t\t\t\tthis._changeBoardSize( sortedBoardSizes[i] );\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (this.puzzle.creator) {\r\n\r\n\t\t\t\t\t//this.puzzle.creator.log.push( sortedBoardSizes[i].handle +\r\n\t\t\t\t\t//\t', tableWidth: ' + table.clientWidth + ', availableWidth: ' + availableWidth\r\n\t\t\t\t\t//);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (table.clientWidth <= availableWidth) {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis.drawConsole();\r\n\t}\r\n\r\n\r\n\t/**\r\n\t *\r\n\t * @private\r\n\t */\r\n\t_makePuzzlePlayable()\r\n\t{\r\n\t\tconst table    = this.gridContainer.querySelector( '.nonogram-puzzle-grid' ),\r\n\t\t\t  cells    = this.gridContainer.querySelectorAll( '.nonogram-puzzle-grid td.puzzle-cell' ),\r\n\t\t\t  allCells = this.gridContainer.querySelectorAll( '.nonogram-puzzle-grid td' )\r\n\t\t;\r\n\r\n\t\tthis.playerClickMode = 1;\r\n\r\n\t\t// set css classes and event handlers for puzzle cells\r\n\r\n\t\tcells.forEach( ( cellElem ) =>\r\n\t\t{\r\n\t\t\tcellElem.classList.add( 'playable' );\r\n\r\n\t\t\t// highlight row/column on mouse hover\r\n\r\n\t\t\tcellElem.addEventListener( 'mouseenter', ( e ) =>\r\n\t\t\t{\r\n\t\t\t\tconst hoverCell = e.currentTarget,\r\n\t\t\t\t\t  row       = hoverCell.getAttribute( 'data-row' ),\r\n\t\t\t\t\t  column    = hoverCell.getAttribute( 'data-column' )\r\n\t\t\t\t;\r\n\r\n\t\t\t\tallCells.forEach( ( cellElem ) =>\r\n\t\t\t\t{\r\n\t\t\t\t\tif (cellElem.getAttribute( 'data-row' ) === row || cellElem.getAttribute( 'data-column' ) === column) {\r\n\t\t\t\t\t\tcellElem.classList.add( 'row-column-highlight' );\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tcellElem.classList.remove( 'row-column-highlight' );\r\n\t\t\t\t\t}\r\n\t\t\t\t} );\r\n\t\t\t} );\r\n\r\n\t\t\t// add cell click event handler\r\n\r\n\t\t\tcellElem.addEventListener( 'click', ( e ) =>\r\n\t\t\t{\r\n\t\t\t\tconst cellElem  = e.currentTarget,\r\n\t\t\t\t\t  cellIndex = cellElem.getAttribute( 'data-index' ),\r\n\t\t\t\t\t  cell      = this.puzzle.getCellByIndex( cellIndex ),\r\n\t\t\t\t\t  solvedP   = document.querySelector( '[data-nonogram-puzzle-grid-solved]' )\r\n\t\t\t\t;\r\n\r\n\t\t\t\te.preventDefault();\r\n\r\n\t\t\t\tcell.userSolution = cell.userSolution === this.playerClickMode ? null : this.playerClickMode;\r\n\r\n\t\t\t\ttable.classList.remove( 'solved' );\r\n\t\t\t\tcellElem.classList.remove( 'user-solved', 'user-positive', 'user-negative', 'solution-positive', 'solution-negative' );\r\n\r\n\t\t\t\tif (cell.userSolution === 1) {\r\n\t\t\t\t\tcellElem.classList.add( 'user-solved', 'user-positive' );\r\n\t\t\t\t} else if (cell.userSolution === 0) {\r\n\t\t\t\t\tcellElem.classList.add( 'user-solved', 'user-negative' );\r\n\t\t\t\t}\r\n\r\n\t\t\t\tcellElem.classList.toggle( 'flipped' );\r\n\r\n\t\t\t\tthis.drawPreview( 'userSolution' );\r\n\r\n\t\t\t\tif (this.puzzle.checkUserSolution()) {\r\n\t\t\t\t\tthis._showPuzzleSolved();\r\n\t\t\t\t} else {\r\n\t\t\t\t\tsolvedP.textContent = '';\r\n\t\t\t\t}\r\n\t\t\t} );\r\n\t\t} );\r\n\r\n\t\t// remove highlighted cells on puzzle grid mouseout\r\n\r\n\t\ttable.addEventListener( 'mouseleave', () =>\r\n\t\t{\r\n\t\t\tallCells.forEach( ( cellElem ) =>\r\n\t\t\t{\r\n\t\t\t\tcellElem.classList.remove( 'row-column-highlight' );\r\n\t\t\t} );\r\n\t\t} );\r\n\t}\r\n\r\n\r\n\t/**\r\n\t *\r\n\t * @private\r\n\t */\r\n\t_resetPuzzle()\r\n\t{\r\n\t\tconst cellElems  = this.gridContainer.querySelectorAll( '.nonogram-puzzle-grid td.puzzle-cell' ),\r\n\t\t\t  puzzleGrid = this.gridContainer.querySelector( '.nonogram-puzzle-grid' ),\r\n\t\t\t  solvedP    = document.querySelector( '[data-nonogram-puzzle-grid-solved]' )\r\n\t\t;\r\n\r\n\t\t// TODO: uncomment confirm ?\r\n\t\t//if (confirm( 'Are you sure you want to _reset the puzzle?' )) {\r\n\r\n\t\tpuzzleGrid.classList.remove( 'solved' );\r\n\t\tsolvedP.textContent = '';\r\n\r\n\t\tthis.puzzle.cells.forEach( ( cell ) =>\r\n\t\t{\r\n\t\t\tcell.userSolution = null;\r\n\t\t} );\r\n\r\n\t\tcellElems.forEach( ( cellElem ) =>\r\n\t\t{\r\n\t\t\tcellElem.classList.remove( 'user-solved', 'user-positive', 'user-negative', 'solution-positive', 'solution-negative' );\r\n\t\t} );\r\n\r\n\t\tthis.gridContainer.querySelector( '[data-nonogram-preview-grid]' ).innerHTML = '';\r\n\r\n\t\tthis.drawPreview( 'userSolution' );\r\n\r\n\t\t//}\r\n\t}\r\n\r\n\r\n\t/**\r\n\t *\r\n\t * @private\r\n\t */\r\n\t_showPuzzleSolved()\r\n\t{\r\n\t\tconst grid       = this.gridContainer.querySelector( '.nonogram-puzzle-grid' ),\r\n\t\t\t  tableCells = document.querySelectorAll( '[data-nonogram-puzzle-grid-table] .puzzle-cell' ),\r\n\t\t\t  solvedP    = document.querySelector( '[data-nonogram-puzzle-grid-solved]' )\r\n\t\t;\r\n\r\n\t\ttableCells.forEach( ( cellElem ) =>\r\n\t\t{\r\n\t\t\tcellElem.classList.remove( 'row-column-highlight' )\r\n\t\t} );\r\n\r\n\t\tgrid.classList.add( 'solved' );\r\n\t\tsolvedP.textContent = 'Solved!';\r\n\t}\r\n\r\n\r\n\t/**\r\n\t *\r\n\t * @param name\r\n\t * @returns {Nonogram.GuiTemplate}\r\n\t * @throws - error if template could not be found\r\n\t * @private\r\n\t */\r\n\t_getTemplate( name )\r\n\t{\r\n\t\tconst ret = this.templates.find( ( template ) =>\r\n\t\t{\r\n\t\t\treturn template.name === name;\r\n\t\t} );\r\n\r\n\t\tif (!ret instanceof Nonogram.GuiTemplate) {\r\n\t\t\tthrow '\"' + name + '\" template not found.';\r\n\t\t}\r\n\r\n\t\treturn ret;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t *\r\n\t * @returns {string}\r\n\t * @private\r\n\t */\r\n\t_resolveThemePath()\r\n\t{\r\n\t\tlet path = '';\r\n\r\n\t\tdocument.querySelectorAll( 'script' ).forEach( ( script ) =>\r\n\t\t{\r\n\t\t\ttry {\r\n\t\t\t\tconst url      = new URL( script.src ),\r\n\t\t\t\t\t  parts    = url.pathname.split( '/' ),\r\n\t\t\t\t\t  fileName = parts.pop()\r\n\t\t\t\t;\r\n\r\n\t\t\t\tif (fileName === 'nonogram.min.js') {\r\n\t\t\t\t\tpath = url.href.replace( fileName, '' ) + 'themes';\r\n\t\t\t\t}\r\n\r\n\t\t\t} catch (err) {\r\n\t\t\t}\r\n\t\t} );\r\n\r\n\t\treturn path;\r\n\t}\r\n\r\n\r\n};\r\n\r\n","import Nonogram from './nonogram';\r\n\r\n\r\n/**\r\n * @class\r\n * @type {Nonogram.GuiTemplate}\r\n * @this Nonogram.GuiTemplate\r\n *\r\n * @property {string} name\r\n * @property {string} path\r\n * @property {string} html\r\n * @property {array} loadedCallbacks\r\n * @property {Promise} loadedPromise - resolves once template has been onLoad and parsed\r\n * @property {boolean} isLoaded\r\n */\r\nNonogram.GuiTemplate = class\r\n{\r\n\t/**\r\n\t * class for loading an html template\r\n\t *\r\n\t * @param name\r\n\t * @param path\r\n\t */\r\n\tconstructor( name, path )\r\n\t{\r\n\t\tthis.name              = name;\r\n\t\tthis.path              = path;\r\n\t\tthis.html              = '';\r\n\t\tthis.onLoadedCallbacks = [];\r\n\t\tthis.isLoaded          = false;\r\n\t\tthis.loadedPromise     = null;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * attach a callback to fire once template has loaded\r\n\t *\r\n\t * @param {function} callback\r\n\t */\r\n\tonLoad( callback )\r\n\t{\r\n\t\tthis.onLoadedCallbacks.push( callback );\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * fired when template is loaded.  executes all onLoad callbacks\r\n\t */\r\n\tfireOnLoaded()\r\n\t{\r\n\t\tthis.onLoadedCallbacks.forEach( ( callback ) =>\r\n\t\t{\r\n\t\t\tcallback();\r\n\t\t} );\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * attempts to fetch a template specified by this.path\r\n\t *\r\n\t * @returns {Promise} - complete when template has been fetched and parsed\r\n\t * @throws - error if template cannot be onLoad\r\n\t */\r\n\tload()\r\n\t{\r\n\t\tthis.loadedPromise = new Promise( ( resolve ) =>\r\n\t\t{\r\n\t\t\tfetch( this.path ).then( ( response ) =>\r\n\t\t\t{\r\n\t\t\t\tif (response.ok) {\r\n\r\n\t\t\t\t\tresponse.text().then( ( text ) =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tthis.html     = text;\r\n\t\t\t\t\t\tthis.isLoaded = true;\r\n\t\t\t\t\t\tthis.fireOnLoaded();\r\n\r\n\t\t\t\t\t\tresolve( this.name + ' onLoad and parsed' );\r\n\t\t\t\t\t} );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tthrow 'loading failed for \"' + this.path + '\"';\r\n\t\t\t\t}\r\n\t\t\t} );\r\n\t\t} );\r\n\r\n\t\treturn this.loadedPromise;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * get the html template as a DOM node\r\n\t * @returns {HTMLDivElement}\r\n\t */\r\n\tgetNode()\r\n\t{\r\n\t\tconst div = document.createElement( 'div' );\r\n\r\n\t\tdiv.innerHTML = this.html;\r\n\r\n\t\treturn div;\r\n\t}\r\n\r\n};\r\n\r\n\r\n","import Nonogram from './nonogram';\r\n\r\n\r\n/**\r\n *\r\n * @type {{'Large Example 1': {hints: {column: *[], row: *[]}, width: number, height: number}, 'Small Example 2': {hints: {column: *[], row: *[]}, width: number, height: number}, 'Medium Example 1': {hints: {column: *[], row: *[]}, width: number, height: number}, 'Small Example 1': {solutionGrid: *[], width: number, height: number}, 'Medium Example 2': {hints: {column: *[], row: *[]}, width: number, height: number}, 'Small Example 3': {hints: {column: *[], row: *[]}, width: number, height: number}}}\r\n */\r\n\r\nNonogram.PuzzleLibrary = {\r\n\r\n\t\"Small Example 1\": {\r\n\t\twidth:        8,\r\n\t\theight:       8,\r\n\t\tsolutionGrid: [\r\n\t\t\t[0, 0, 0, 0, 1, 1, 1, 0],\r\n\t\t\t[0, 0, 0, 1, 1, 1, 1, 1],\r\n\t\t\t[0, 0, 0, 1, 1, 1, 1, 1],\r\n\t\t\t[1, 1, 0, 0, 1, 1, 1, 0],\r\n\t\t\t[0, 1, 0, 1, 1, 1, 1, 1],\r\n\t\t\t[1, 1, 0, 1, 0, 0, 0, 1],\r\n\t\t\t[1, 1, 0, 1, 1, 1, 1, 1],\r\n\t\t\t[1, 0, 0, 0, 1, 1, 1, 0]\r\n\t\t]\r\n\t},\r\n\r\n\t\"Small Example 2\": {\r\n\t\twidth:  8,\r\n\t\theight: 8,\r\n\t\thints:  {\r\n\t\t\trow:    [[3], [5], [5], [2, 3], [1, 5], [2, 1, 1], [2, 5], [1, 3]],\r\n\t\t\tcolumn: [[1, 3], [4], [], [2, 3], [5, 2], [5, 2], [5, 2], [2, 3]]\r\n\t\t}\r\n\t},\r\n\r\n\t\"Small Example 3\": {\r\n\t\twidth:  10,\r\n\t\theight: 10,\r\n\t\thints:  {\r\n\t\t\tcolumn: [\r\n\t\t\t\t[3], [1, 1], [1], [6], [8], [2, 1], [4, 1], [10], [3, 1], [3]\r\n\t\t\t],\r\n\t\t\trow:    [\r\n\t\t\t\t[4], [5], [2, 3], [2, 3], [2, 1], [2, 1], [2, 1], [10], [1, 1, 1], [2, 1, 1]\r\n\t\t\t]\r\n\t\t}\r\n\t},\r\n\r\n\t\"Medium Example 1\": {\r\n\t\twidth:  16,\r\n\t\theight: 18,\r\n\t\thints:  {\r\n\t\t\tcolumn: [\r\n\t\t\t\t[5], [4, 3, 3], [7, 6, 2], [4, 3, 4, 1], [3, 2, 4, 1, 2], [2, 6, 4], [3, 3, 1, 1], [4, 6, 4], [6, 4, 1, 1], [4, 3, 4, 1], [7, 6, 2], [4, 3, 3], [5], [3], [5, 3, 3], [2, 4, 1, 2]\r\n\t\t\t],\r\n\t\t\trow:    [\r\n\t\t\t\t[5], [9], [3, 5], [3, 5, 1], [4, 4, 2], [2, 1, 1, 2, 1], [2, 2, 1], [2, 3, 2, 1], [7, 2], [9, 1], [2, 2, 2, 2, 2], [3, 2, 2, 3, 2], [4, 1, 1, 6], [1, 2, 2, 2], [16], [2, 1, 1, 1, 1, 2, 1], [2, 2, 2, 2, 2], [9, 1]\r\n\t\t\t]\r\n\t\t}\r\n\t},\r\n\r\n\r\n\t\"Medium Example 2\": {\r\n\t\twidth:  15,\r\n\t\theight: 15,\r\n\t\thints:  {\r\n\t\t\tcolumn: [\r\n\t\t\t\t[4], [3, 1], [2, 3], [1, 2, 2], [1, 2, 1], [1, 1, 1, 1], [4, 3, 3], [2, 2, 4, 3], [1, 2, 5, 1], [1, 2, 4, 1], [1, 2, 5, 1], [2, 2, 4, 3], [9, 3], [5, 1, 1], [6, 1]\r\n\t\t\t],\r\n\t\t\trow:    [\r\n\t\t\t\t[4, 5], [3, 2, 2], [2, 1, 1], [1, 4, 3], [2, 9], [2, 8], [2, 3], [12], [1, 7, 1], [9], [5], [1, 1], [2, 2], [3, 3], [1, 7, 1]\r\n\t\t\t]\r\n\t\t}\r\n\t},\r\n\r\n\t\"Large Example 1\": {\r\n\t\twidth:  30,\r\n\t\theight: 30,\r\n\t\thints:  {\r\n\t\t\tcolumn: [\r\n\t\t\t\t[19, 9], [13, 1, 2, 1, 5], [11, 4, 1, 1, 2, 3], [10, 6, 1, 4, 1, 1], [9, 7, 1, 1, 3, 2], [3, 4, 11, 1, 6], [2, 1, 2, 3, 3, 3, 7], [2, 2, 1, 2, 4, 3, 8], [3, 2, 2, 1, 2, 6, 7], [1, 3, 3, 4, 1, 4, 4, 1], [5, 4, 2, 5, 2, 2], [1, 3, 11, 1, 2, 4], [3, 2, 14, 5], [2, 2, 1, 14, 7], [1, 2, 2, 2, 10, 2], [2, 1, 3, 2, 6, 3, 3], [5, 6, 6, 2, 2, 4], [6, 4, 4, 3, 3, 3], [6, 3, 2, 1, 1, 3, 5, 2], [6, 1, 2, 2, 2, 2, 2, 3], [7, 1, 9, 2, 4], [7, 3, 1, 2, 2, 3], [8, 2, 5, 4, 3], [6, 1, 7, 11], [5, 1, 3, 2, 12], [5, 2, 2, 2, 3, 11], [4, 5, 4, 3, 10], [3, 14, 10], [3, 3, 5, 2, 9], [4, 3, 3, 10]\r\n\t\t\t],\r\n\t\t\trow:    [\r\n\t\t\t\t[10, 19], [9, 1, 2, 15], [6, 1, 1, 1, 14], [5, 2, 3, 2, 11, 1], [6, 7, 11, 1], [7, 5, 7, 3], [8, 4, 3, 4], [6, 4, 5, 1, 4, 1], [5, 8, 6, 2, 1], [4, 10, 3, 3, 3, 1], [3, 3, 5, 2, 4, 2, 2], [2, 3, 3, 3, 2, 4, 2, 3], [2, 3, 1, 1, 5, 2, 1, 6], [1, 4, 3, 4, 2, 2, 2, 4], [1, 4, 3, 4, 5, 3, 3], [1, 5, 5, 2, 1, 4, 1, 1], [1, 15, 3, 2, 3, 1], [2, 4, 7, 2, 2, 3, 1], [1, 4, 4, 7, 2, 1, 3], [1, 2, 3, 4, 3, 3, 1], [1, 1, 3, 5, 2, 6, 1], [1, 1, 1, 4, 4, 9], [2, 3, 1, 1, 1, 9], [1, 2, 4, 1, 1, 6, 8], [1, 10, 1, 7, 7], [2, 8, 2, 1, 2, 1, 7], [3, 6, 3, 1, 1, 1, 7], [4, 4, 4, 3, 11], [3, 5, 20], [2, 7, 19]\r\n\t\t\t]\r\n\t\t}\r\n\t}\r\n};\r\n","import Nonogram from './nonogram';\r\n\r\n\r\nexport default Nonogram;"],"sourceRoot":""}