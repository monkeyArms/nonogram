(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["Nonogram"] = factory();
	else
		root["Nonogram"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "dist/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/nonogram/creator.js":
/*!*********************************!*\
  !*** ./src/nonogram/creator.js ***!
  \*********************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _nonogram__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./nonogram */ \"./src/nonogram/nonogram.js\");\n/* harmony import */ var _nonogram__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nonogram__WEBPACK_IMPORTED_MODULE_0__);\n\r\n\r\n\r\n/**\r\n * @class\r\n * @type {Nonogram.Creator}\r\n * @this Nonogram.Creator\r\n *\r\n * creates nonogram puzzles\r\n *\r\n * @property {Nonogram.Puzzle} this.puzzle\r\n * @property {array} this.log\r\n */\r\n_nonogram__WEBPACK_IMPORTED_MODULE_0___default.a.Creator = class\r\n{\r\n\t/**\r\n\t * creates a new puzzle\r\n\t *\r\n\t * @param {number} width\r\n\t * @param {number} height\r\n\t */\r\n\tconstructor( width, height )\r\n\t{\r\n\t\tthis.puzzle = new _nonogram__WEBPACK_IMPORTED_MODULE_0___default.a.Puzzle( width, height );\r\n\t\tthis.log    = [];\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * populates the puzzles rows and columns with random, solvable values\r\n\t *\r\n\t * @param {number|null} density - a floating point number between 0 and 1 (optional) that controls the percentage of filled cell likelihood.\r\n\t *                                    If not supplied a random value between 0.2 and 0.8 will be generated.\r\n\t *                                    Note that this does not make a puzzle grid filled in by the percentage,\r\n\t *                                    rather it's a 'suggestion' that is run through randomization on a cell-by-cell basis.\r\n\t * @returns {Nonogram.Puzzle|Puzzle|class}\r\n\t */\r\n\tcreateRandom( density )\r\n\t{\r\n\t\tconst start      = new Date().getTime();\r\n\t\tlet puzzleValid  = false,\r\n\t\t\tdensityValid = typeof density === 'number' && density >= 0 && density <= 1,\r\n\t\t\tcellsFilled, chanceOfCellFill, solutionGrid, rowArray, cellValue, solver, i, elapsed\r\n\t\t;\r\n\r\n\r\n\t\twhile (puzzleValid === false) {\r\n\r\n\t\t\tchanceOfCellFill = densityValid ? density : _nonogram__WEBPACK_IMPORTED_MODULE_0___default.a.Utility.getRandomIntBetween( 200, 800 ) / 1000;\r\n\t\t\tsolutionGrid     = [];\r\n\t\t\trowArray         = [];\r\n\t\t\tcellsFilled      = 0;\r\n\r\n\t\t\tthis.log.push( 'Creating random ' +\r\n\t\t\t\tthis.puzzle.width + 'x' + this.puzzle.height +\r\n\t\t\t\t' puzzle with density of ' + chanceOfCellFill + '...'\r\n\t\t\t);\r\n\r\n\t\t\t// create puzzle grid randomly using density as a factor\r\n\r\n\t\t\tfor (i = 0; i < this.puzzle.totalCells; i++) {\r\n\r\n\t\t\t\tcellValue = Math.random() < chanceOfCellFill ? 1 : 0;\r\n\r\n\t\t\t\tcellsFilled += cellValue;\r\n\r\n\t\t\t\tif (i % this.puzzle.width === 0 && i > 0) {\r\n\t\t\t\t\tsolutionGrid.push( rowArray );\r\n\t\t\t\t\trowArray = [];\r\n\t\t\t\t}\r\n\r\n\t\t\t\trowArray.push( cellValue );\r\n\t\t\t}\r\n\r\n\t\t\t// ensure that at least one cell is filled, and that not all of them are\r\n\r\n\t\t\tif (cellsFilled === 0) {\r\n\r\n\t\t\t\tthis.log.push( 'Generated puzzle has no cells filled.  Trying again...' );\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\t} else if (cellsFilled === this.puzzle.totalCells) {\r\n\r\n\t\t\t\tthis.log.push( 'Generated puzzle has all cells filled.  Trying again...' );\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\r\n\t\t\t// populate the solution grid\r\n\t\t\tsolutionGrid.push( rowArray );\r\n\r\n\t\t\t// populate the grid\r\n\t\t\tthis.puzzle.createFromGrid( solutionGrid );\r\n\r\n\t\t\t// ensure that puzzle is solvable\r\n\t\t\tsolver = new _nonogram__WEBPACK_IMPORTED_MODULE_0___default.a.Solver( this.puzzle );\r\n\r\n\t\t\tif (solver.solve()) {\r\n\r\n\t\t\t\tpuzzleValid = true;\r\n\t\t\t\telapsed     = (new Date().getTime() - start) / 1000;\r\n\r\n\t\t\t\tthis.log.push( 'Puzzle is valid.' );\r\n\t\t\t\tthis.log.push( '-----------------------------------' );\r\n\t\t\t\tthis.log.push( 'Puzzle generated in ' + elapsed + ' seconds.' );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis.log.push( 'Puzzle cannot be solved.  Trying again...' );\r\n\t\t\t}\r\n\r\n\t\t\tthis.log.push( '-----------------------------------' );\r\n\t\t}\r\n\r\n\t\tthis.puzzle.creator = this;\r\n\r\n\t\treturn this.puzzle;\r\n\t}\r\n\r\n};\r\n\r\n\n\n//# sourceURL=webpack://Nonogram/./src/nonogram/creator.js?");

/***/ }),

/***/ "./src/nonogram/export.js":
/*!********************************!*\
  !*** ./src/nonogram/export.js ***!
  \********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _nonogram__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./nonogram */ \"./src/nonogram/nonogram.js\");\n/* harmony import */ var _nonogram__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nonogram__WEBPACK_IMPORTED_MODULE_0__);\n\r\n\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (_nonogram__WEBPACK_IMPORTED_MODULE_0___default.a);\n\n//# sourceURL=webpack://Nonogram/./src/nonogram/export.js?");

/***/ }),

/***/ "./src/nonogram/gui-template.js":
/*!**************************************!*\
  !*** ./src/nonogram/gui-template.js ***!
  \**************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _nonogram__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./nonogram */ \"./src/nonogram/nonogram.js\");\n/* harmony import */ var _nonogram__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nonogram__WEBPACK_IMPORTED_MODULE_0__);\n\r\n\r\n\r\n/**\r\n * @class\r\n * @type {GuiTemplate}\r\n * @this GuiTemplate\r\n *\r\n * @property {string} name\r\n * @property {string} path\r\n * @property {string} html\r\n * @property {array} loadedCallbacks\r\n */\r\n_nonogram__WEBPACK_IMPORTED_MODULE_0___default.a.GuiTemplate = class\r\n{\r\n\t/**\r\n\t *\r\n\t * @param name\r\n\t * @param path\r\n\t */\r\n\tconstructor( name, path )\r\n\t{\r\n\t\tthis.name              = name;\r\n\t\tthis.path              = path;\r\n\t\tthis.html              = '';\r\n\t\tthis.onLoadedCallbacks = [];\r\n\t\tthis.isLoaded          = false;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t *\r\n\t * @param {function} callback\r\n\t */\r\n\tloaded( callback )\r\n\t{\r\n\t\tthis.onLoadedCallbacks.push( callback );\r\n\t}\r\n\r\n\r\n\t/**\r\n\t *\r\n\t */\r\n\tfireOnLoaded()\r\n\t{\r\n\t\tthis.onLoadedCallbacks.forEach( ( callback ) =>\r\n\t\t{\r\n\t\t\tcallback();\r\n\t\t} );\r\n\t}\r\n\r\n\r\n\t/**\r\n\t *\r\n\t */\r\n\tload()\r\n\t{\r\n\t\tconst self = this;\r\n\r\n\t\tfetch( self.path ).then( ( response ) =>\r\n\t\t{\r\n\t\t\tif (response.ok) {\r\n\r\n\t\t\t\tresponse.text().then( ( text ) =>\r\n\t\t\t\t{\r\n\t\t\t\t\tself.html     = text;\r\n\t\t\t\t\tself.isLoaded = true;\r\n\t\t\t\t\tself.fireOnLoaded();\r\n\t\t\t\t} );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tconsole.log( 'loading failed for \"' + self.path + '\"' );\r\n\t\t\t}\r\n\t\t} );\r\n\t}\r\n\r\n\r\n\t/**\r\n\t *\r\n\t * @returns {HTMLDivElement}\r\n\t */\r\n\tgetNode()\r\n\t{\r\n\t\tconst div = document.createElement( 'div' );\r\n\r\n\t\tdiv.innerHTML = this.html;\r\n\r\n\t\treturn div;\r\n\t}\r\n\r\n};\r\n\r\n\r\n\n\n//# sourceURL=webpack://Nonogram/./src/nonogram/gui-template.js?");

/***/ }),

/***/ "./src/nonogram/gui.js":
/*!*****************************!*\
  !*** ./src/nonogram/gui.js ***!
  \*****************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _nonogram__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./nonogram */ \"./src/nonogram/nonogram.js\");\n/* harmony import */ var _nonogram__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nonogram__WEBPACK_IMPORTED_MODULE_0__);\n\r\n\r\n\r\n/**\r\n * @class\r\n * @type {Nonogram.Gui}\r\n * @this Nonogram.Gui\r\n *\r\n * provides a user interface for interacting with nonogram puzzles\r\n *\r\n * @property {Nonogram.Puzzle} this.puzzle\r\n * @property {HTMLElement} this.gridContainer - container element for the puzzle grid ui\r\n * @property {array} this.templates - array of Nonogram.GuiTemplate objects\r\n * @property {string|null} this.theme - the theme to use, located in the themes/ directory\r\n * @property {string} this.themePath - the path to the specified theme located in themes/{theme}\r\n * @property {string} this.themeStylesheetPath - the path to the theme stylesheet located in themes/{theme}/styles.css\r\n * @property {string} this.themeTemplatesPath - the path to the theme template directory located in themes/{theme}/templates\r\n * @property {int} this.playerClickMode - whether to fill or cross a cell on click\r\n */\r\n_nonogram__WEBPACK_IMPORTED_MODULE_0___default.a.Gui = class\r\n{\r\n\r\n\t/**\r\n\t *\r\n\t * @param {string|null} theme - the theme to use, located in the themes/ directory\r\n\t */\r\n\tconstructor( theme )\r\n\t{\r\n\t\tconst self = this,\r\n\t\t\t  head = document.querySelector( 'head' ),\r\n\t\t\t  link = document.createElement( 'link' )\r\n\t\t;\r\n\r\n\t\t// set up theme\r\n\t\tself.theme     = theme || 'default';\r\n\t\tself.themePath = self._resolveThemePath() + '/' + this.theme;\r\n\r\n\t\t// load theme stylesheet\r\n\t\tself.themeStylesheetPath = self.themePath + '/styles.css';\r\n\t\tlink.rel                 = 'stylesheet';\r\n\t\tlink.type                = 'text/css';\r\n\t\tlink.href                = self.themeStylesheetPath;\r\n\t\thead.appendChild( link );\r\n\r\n\t\t// set up templates\r\n\t\tself.themeTemplatesPath = self.themePath + '/templates';\r\n\t\tself.templates          = [\r\n\t\t\tnew _nonogram__WEBPACK_IMPORTED_MODULE_0___default.a.GuiTemplate( 'gameControls', self.themeTemplatesPath + '/controls-game.html' ),\r\n\t\t\tnew _nonogram__WEBPACK_IMPORTED_MODULE_0___default.a.GuiTemplate( 'generateControls', self.themeTemplatesPath + '/controls-generate.html' ),\r\n\t\t\tnew _nonogram__WEBPACK_IMPORTED_MODULE_0___default.a.GuiTemplate( 'console', self.themeTemplatesPath + '/console.html' ),\r\n\t\t\tnew _nonogram__WEBPACK_IMPORTED_MODULE_0___default.a.GuiTemplate( 'previewGrid', self.themeTemplatesPath + '/preview-grid.html' ),\r\n\t\t\tnew _nonogram__WEBPACK_IMPORTED_MODULE_0___default.a.GuiTemplate( 'puzzleGrid', self.themeTemplatesPath + '/puzzle-grid.html' ),\r\n\t\t];\r\n\r\n\t\t// load templates\r\n\t\tself.templates.forEach( ( template ) =>\r\n\t\t{\r\n\t\t\ttemplate.load();\r\n\t\t} );\r\n\t}\r\n\r\n\r\n\t// ######################################################################################\tpublic drawing methods\r\n\r\n\t/**\r\n\t * - draw all user interfaces\r\n\t */\r\n\tdraw( puzzle )\r\n\t{\r\n\t\tthis.drawPuzzle( puzzle );\r\n\t\tthis.drawGameControls();\r\n\t\tthis.drawGenerateControls();\r\n\t\tthis.drawConsole();\r\n\t}\r\n\r\n\r\n\t/**\r\n\t *    - draw the game controls ui\r\n\t */\r\n\tdrawGameControls()\r\n\t{\r\n\t\tconst self     = this,\r\n\t\t\t  template = self._getTemplate( 'gameControls' );\r\n\r\n\r\n\t\tconst draw = () =>\r\n\t\t{\r\n\t\t\tconst container = document.querySelector( '[data-nonogram-game-controls]' ),\r\n\t\t\t\t  node      = template.getNode()\r\n\t\t\t;\r\n\t\t\tlet fillModeCheckbox;\r\n\r\n\t\t\t// insert template\r\n\t\t\tcontainer.innerHtml = container.textContent = '';\r\n\t\t\tcontainer.appendChild( node );\r\n\r\n\t\t\t// add event handlers\r\n\t\t\tfillModeCheckbox = document.querySelector( '#nonogram-puzzle-fill-mode' );\r\n\r\n\t\t\tfillModeCheckbox.addEventListener( 'change', () =>\r\n\t\t\t{\r\n\t\t\t\tconst fillModeLabel = document.querySelector( '[for=\"nonogram-puzzle-fill-mode\"]' ),\r\n\t\t\t\t\t  prevActive    = fillModeLabel.querySelector( '.active' ),\r\n\t\t\t\t\t  prevInactive  = fillModeLabel.querySelector( '.inactive' )\r\n\t\t\t\t;\r\n\r\n\t\t\t\tprevActive.classList.remove( 'active' );\r\n\t\t\t\tprevActive.classList.add( 'inactive' );\r\n\t\t\t\tprevInactive.classList.remove( 'inactive' );\r\n\t\t\t\tprevInactive.classList.add( 'active' );\r\n\r\n\t\t\t\tif (fillModeCheckbox.checked) {\r\n\t\t\t\t\tfillModeLabel.classList.add( 'on' );\r\n\t\t\t\t\tself.playerClickMode = 0;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tfillModeLabel.classList.remove( 'on' );\r\n\t\t\t\t\tself.playerClickMode = 1;\r\n\t\t\t\t}\r\n\t\t\t} );\r\n\r\n\t\t\twindow.addEventListener( 'keyup', ( e ) =>\r\n\t\t\t{\r\n\t\t\t\tif (e.key && e.key === 'x') {\r\n\t\t\t\t\tfillModeCheckbox.dispatchEvent( new MouseEvent( 'click' ) );\r\n\t\t\t\t}\r\n\t\t\t} );\r\n\t\t};\r\n\r\n\t\t// fire draw method\r\n\t\tif (!template.isLoaded) {\r\n\t\t\ttemplate.loaded( draw );\r\n\t\t} else {\r\n\t\t\tdraw();\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * - draw puzzle generating/solving/reseting ui\r\n\t */\r\n\tdrawGenerateControls()\r\n\t{\r\n\t\tconst self     = this,\r\n\t\t\t  template = self._getTemplate( 'generateControls' );\r\n\r\n\r\n\t\tconst draw = () =>\r\n\t\t{\r\n\t\t\tconst container     = document.querySelector( '[data-nonogram-generate-controls]' ),\r\n\t\t\t\t  node          = template.getNode(),\r\n\t\t\t\t  widthSelect   = node.querySelector( '[data-nonogram-generate-width]' ),\r\n\t\t\t\t  heightSelect  = node.querySelector( '[data-nonogram-generate-height]' ),\r\n\t\t\t\t  widthOptions  = node.querySelector( '[data-nonogram-generate-width-options]' ),\r\n\t\t\t\t  heightOptions = node.querySelector( '[data-nonogram-generate-height-options]' )\r\n\t\t\t;\r\n\t\t\tlet i, clonedWidthOptions, cloneHeightOptions, widthOption, heightOption, generate, reset, solve;\r\n\r\n\r\n\t\t\t// populate width/height select elements\r\n\t\t\tfor (i = 5; i <= 30; i++) {\r\n\r\n\t\t\t\tclonedWidthOptions       = document.importNode( widthOptions.content, true );\r\n\t\t\t\tcloneHeightOptions       = document.importNode( heightOptions.content, true );\r\n\t\t\t\twidthOption              = clonedWidthOptions.querySelector( 'option' );\r\n\t\t\t\twidthOption.textContent  = widthOption.value = i;\r\n\t\t\t\theightOption             = cloneHeightOptions.querySelector( 'option' );\r\n\t\t\t\theightOption.textContent = heightOption.value = i;\r\n\r\n\t\t\t\tif (self.puzzle.width === i) {\r\n\t\t\t\t\twidthOption.setAttribute( 'selected', 'selected' );\r\n\t\t\t\t}\r\n\t\t\t\tif (self.puzzle.height === i) {\r\n\t\t\t\t\theightOption.setAttribute( 'selected', 'selected' );\r\n\t\t\t\t}\r\n\r\n\t\t\t\twidthSelect.appendChild( widthOption );\r\n\t\t\t\theightSelect.appendChild( heightOption );\r\n\t\t\t}\r\n\r\n\t\t\t// insert template\r\n\t\t\tcontainer.innerHtml = container.textContent = '';\r\n\t\t\tcontainer.appendChild( node );\r\n\r\n\t\t\t// add event handlers\r\n\t\t\tgenerate = document.querySelector( '[data-nonogram-generate-button]' );\r\n\t\t\treset    = document.querySelector( '[data-nonogram-game-reset]' );\r\n\t\t\tsolve    = document.querySelector( '[data-nonogram-game-solve]' );\r\n\r\n\t\t\tgenerate.addEventListener( 'click', () =>\r\n\t\t\t{\r\n\t\t\t\tconst widthSelect  = document.querySelector( '[data-nonogram-generate-width]' ),\r\n\t\t\t\t\t  heightSelect = document.querySelector( '[data-nonogram-generate-height]' ),\r\n\t\t\t\t\t  width        = widthSelect.value,\r\n\t\t\t\t\t  height       = heightSelect.value,\r\n\t\t\t\t\t  creator      = new _nonogram__WEBPACK_IMPORTED_MODULE_0___default.a.Creator( width, height ),\r\n\t\t\t\t\t  puzzle       = creator.createRandom()\r\n\t\t\t\t;\r\n\r\n\t\t\t\tself.draw( puzzle );\r\n\t\t\t} );\r\n\r\n\t\t\treset.addEventListener( 'click', () =>\r\n\t\t\t{\r\n\t\t\t\tself._resetPuzzle();\r\n\t\t\t} );\r\n\r\n\t\t\tsolve.addEventListener( 'click', () =>\r\n\t\t\t{\r\n\t\t\t\t// TODO: uncomment confirm ?\r\n\r\n\t\t\t\t//if (confirm( 'Are you sure you want to see the answer?' )) {\r\n\t\t\t\tself.drawSolution();\r\n\t\t\t\tself.drawPreview( 'solution' );\r\n\t\t\t\t//}\r\n\t\t\t} );\r\n\t\t};\r\n\r\n\r\n\t\t// fire draw method\r\n\t\tif (!template.isLoaded) {\r\n\t\t\ttemplate.loaded( draw );\r\n\t\t} else {\r\n\t\t\tdraw();\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * - draw the console\r\n\t */\r\n\tdrawConsole()\r\n\t{\r\n\t\tconst self     = this,\r\n\t\t\t  template = self._getTemplate( 'console' )\r\n\t\t;\r\n\r\n\t\tconst draw = () =>\r\n\t\t{\r\n\t\t\tself.updateConsole();\r\n\t\t};\r\n\r\n\t\t// fire draw method\r\n\t\tif (!template.isLoaded) {\r\n\t\t\ttemplate.loaded( draw );\r\n\t\t} else {\r\n\t\t\tdraw();\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * - update console with Nonogram.Creator log\r\n\t */\r\n\tupdateConsole()\r\n\t{\r\n\t\tconst self      = this,\r\n\t\t\t  template  = self._getTemplate( 'console' ),\r\n\t\t\t  container = document.querySelector( '[data-nonogram-console]' ),\r\n\t\t\t  node      = template.getNode(),\r\n\t\t\t  output    = node.querySelector( '[data-nonogram-console-output]' ),\r\n\t\t\t  line      = node.querySelector( '[data-nonogram-console-line]' )\r\n\t\t;\r\n\r\n\t\tif (self.puzzle.creator instanceof _nonogram__WEBPACK_IMPORTED_MODULE_0___default.a.Creator) {\r\n\t\t\tself.puzzle.creator.log.forEach( ( text ) =>\r\n\t\t\t{\r\n\t\t\t\tconst clonedLine = document.importNode( line.content, true ),\r\n\t\t\t\t\t  code       = clonedLine.querySelector( 'code' );\r\n\r\n\t\t\t\tcode.textContent = text;\r\n\t\t\t\toutput.appendChild( code );\r\n\t\t\t} );\r\n\t\t}\r\n\r\n\r\n\t\t// insert template\r\n\t\tcontainer.innerHtml = container.textContent = '';\r\n\t\tcontainer.appendChild( node );\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * - draw the preview grid for the current state of the puzzle\r\n\t *\r\n\t * @param solutionType\r\n\t */\r\n\tdrawPreview( solutionType )\r\n\t{\r\n\t\tconst self     = this,\r\n\t\t\t  template = self._getTemplate( 'previewGrid' )\r\n\t\t;\r\n\r\n\t\tconst draw = () =>\r\n\t\t{\r\n\t\t\tconst container = document.querySelector( '[data-nonogram-preview-grid]' ),\r\n\t\t\t\t  node      = template.getNode()\r\n\t\t\t;\r\n\r\n\t\t\t// insert template\r\n\r\n\t\t\tcontainer.innerHtml = container.textContent = '';\r\n\t\t\tcontainer.appendChild( node.querySelector( '[data-nonogram-preview]' ) );\r\n\r\n\t\t\t// draw preview canvas\r\n\r\n\t\t\tconst canvas          = document.querySelector( '[data-nonogram-preview-canvas]' ),\r\n\t\t\t\t  ctx             = canvas.getContext( '2d' ),\r\n\t\t\t\t  parentContainer = canvas.parentElement.parentElement.parentElement,\r\n\t\t\t\t  parentWidth     = parentContainer.offsetWidth,\r\n\t\t\t\t  parentHeight    = parentContainer.offsetHeight,\r\n\t\t\t\t  containerRatio  = parentWidth / parentHeight,\r\n\t\t\t\t  puzzleRatio     = self.puzzle.width / self.puzzle.height\r\n\t\t\t;\r\n\t\t\tlet cellSize;\r\n\r\n\t\t\tif (containerRatio > puzzleRatio) {\r\n\t\t\t\tcellSize = Math.floor( parentHeight / self.puzzle.height );\r\n\t\t\t} else {\r\n\t\t\t\tcellSize = Math.floor( parentWidth / self.puzzle.width );\r\n\t\t\t}\r\n\r\n\t\t\tcanvas.width  = cellSize * self.puzzle.width;\r\n\t\t\tcanvas.height = cellSize * self.puzzle.height;\r\n\r\n\t\t\tself.puzzle.cells.forEach( ( cell ) =>\r\n\t\t\t{\r\n\t\t\t\tif (cell[solutionType] === 1) {\r\n\t\t\t\t\tctx.fillRect( cell.column * cellSize, cell.row * cellSize, cellSize, cellSize );\r\n\t\t\t\t}\r\n\t\t\t} );\r\n\t\t};\r\n\r\n\t\t// fire draw method\r\n\t\tif (!template.isLoaded) {\r\n\t\t\ttemplate.loaded( draw );\r\n\t\t} else {\r\n\t\t\tdraw();\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * - draw the puzzle ui\r\n\t *\r\n\t * @param {Nonogram.Puzzle} puzzle\r\n\t */\r\n\tdrawPuzzle( puzzle )\r\n\t{\r\n\t\tconst self     = this,\r\n\t\t\t  template = self._getTemplate( 'puzzleGrid' )\r\n\t\t;\r\n\r\n\t\tself.puzzle        = puzzle;\r\n\t\tself.gridContainer = document.querySelector( '[data-nonogram-puzzle-grid]' );\r\n\r\n\r\n\t\tconst draw = () =>\r\n\t\t{\r\n\t\t\tconst container       = self.gridContainer,\r\n\t\t\t\t  node            = template.getNode(),\r\n\t\t\t\t  theadThTemplate = node.querySelector( '[data-nonogram-puzzle-grid-table-thead-th]' ),\r\n\t\t\t\t  rowTemplate     = node.querySelector( '[data-nonogram-puzzle-grid-table-row]' ),\r\n\t\t\t\t  cellClasses     = {\r\n\t\t\t\t\t  tl: 0,\r\n\t\t\t\t\t  tr: self.puzzle.width - 1,\r\n\t\t\t\t\t  bl: (self.puzzle.width * self.puzzle.height) - self.puzzle.width,\r\n\t\t\t\t\t  br: (self.puzzle.width * self.puzzle.height) - 1,\r\n\t\t\t\t  }\r\n\t\t\t;\r\n\r\n\t\t\t// table header\r\n\t\t\tself.puzzle.columnHints.forEach( ( hints, columnIndex ) =>\r\n\t\t\t{\r\n\t\t\t\tconst clonedTheadThTemplate = document.importNode( theadThTemplate.content, true ),\r\n\t\t\t\t\t  theadTh               = clonedTheadThTemplate.querySelector( 'th' ),\r\n\t\t\t\t\t  fillDiv               = theadTh.querySelector( '.fill' );\r\n\r\n\t\t\t\ttheadTh.setAttribute( 'data-column', columnIndex.toString() );\r\n\t\t\t\ttheadTh.classList.add( 'hint', 'top' );\r\n\r\n\t\t\t\t// add hints\r\n\t\t\t\thints.forEach( ( hint ) =>\r\n\t\t\t\t{\r\n\t\t\t\t\tlet span = document.createElement( 'span' );\r\n\r\n\t\t\t\t\tspan.textContent = hint;\r\n\t\t\t\t\tfillDiv.appendChild( span );\r\n\t\t\t\t} );\r\n\r\n\t\t\t\ttheadThTemplate.parentNode.insertBefore( theadTh, theadThTemplate );\r\n\t\t\t} );\r\n\r\n\r\n\t\t\t// table rows\r\n\r\n\t\t\tself.puzzle.grid.forEach( ( row, rowKey ) =>\r\n\t\t\t{\r\n\t\t\t\tconst cells             = self.puzzle.getRowCells( rowKey ),\r\n\t\t\t\t\t  clonedRowTemplate = document.importNode( rowTemplate.content, true ),\r\n\t\t\t\t\t  tr                = clonedRowTemplate.querySelector( 'tr' ),\r\n\t\t\t\t\t  cellTemplate      = tr.querySelector( '[data-nonogram-puzzle-grid-table-cell]' ),\r\n\t\t\t\t\t  hintsFillDiv      = tr.querySelector( '[data-row-hints] .fill' )\r\n\t\t\t\t;\r\n\r\n\t\t\t\ttr.setAttribute( 'data-row', rowKey.toString() );\r\n\r\n\t\t\t\t// hint cell\r\n\t\t\t\tself.puzzle.rowHints[rowKey].forEach( ( hint ) =>\r\n\t\t\t\t{\r\n\t\t\t\t\tlet span = document.createElement( 'span' );\r\n\r\n\t\t\t\t\tspan.textContent = hint;\r\n\t\t\t\t\thintsFillDiv.appendChild( span );\r\n\t\t\t\t} );\r\n\r\n\t\t\t\t// grid cells\r\n\t\t\t\tcells.forEach( ( cell ) =>\r\n\t\t\t\t{\r\n\t\t\t\t\tconst clonedCellTemplate = document.importNode( cellTemplate.content, true ),\r\n\t\t\t\t\t\t  td                 = clonedCellTemplate.querySelector( 'td' )\r\n\t\t\t\t\t;\r\n\r\n\t\t\t\t\ttd.setAttribute( 'data-index', cell.index );\r\n\t\t\t\t\ttd.setAttribute( 'data-column', cell.column );\r\n\t\t\t\t\ttd.setAttribute( 'data-row', cell.row );\r\n\t\t\t\t\ttd.classList.add( 'puzzle-cell', 'flippable' );\r\n\r\n\t\t\t\t\tObject.keys( cellClasses ).forEach( ( cssClass ) =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif (cell.index === cellClasses[cssClass]) {\r\n\t\t\t\t\t\t\ttd.classList.add( cssClass );\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} );\r\n\r\n\t\t\t\t\ttr.appendChild( td );\r\n\t\t\t\t} );\r\n\r\n\t\t\t\trowTemplate.parentNode.appendChild( tr );\r\n\t\t\t} );\r\n\r\n\r\n\t\t\t// insert template\r\n\t\t\tcontainer.innerHtml = container.textContent = '';\r\n\t\t\tcontainer.appendChild( node );\r\n\r\n\t\t\tself._makePuzzlePlayable();\r\n\t\t\tself.drawPreview( 'userSolution' );\r\n\t\t};\r\n\r\n\t\t// fire draw method\r\n\t\tif (!template.isLoaded) {\r\n\t\t\ttemplate.loaded( draw );\r\n\t\t} else {\r\n\t\t\tdraw();\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * - draw the solution to the current puzzle\r\n\t */\r\n\tdrawSolution()\r\n\t{\r\n\t\tconst self      = this,\r\n\t\t\t  filledTds = self.gridContainer.querySelectorAll( 'td.filled' )\r\n\t\t;\r\n\r\n\t\tfilledTds.forEach( ( td ) =>\r\n\t\t{\r\n\t\t\ttd.classList.remove( 'filled', 'solution-positive', 'solution-negative', 'user-positive', 'user-negative', 'flipped' );\r\n\t\t} );\r\n\r\n\t\tself.puzzle.cells.forEach( ( cell ) =>\r\n\t\t{\r\n\t\t\tconst cellElem = self.gridContainer.querySelector( 'td[data-index=\"' + cell.index + '\"]' );\r\n\r\n\t\t\tcell.userSolution = cell.solution;\r\n\t\t\tcellElem.classList.add( 'user-solved' );\r\n\r\n\t\t\tif (cell.solution === 1) {\r\n\t\t\t\tcellElem.classList.add( 'solution-positive', 'user-positive', 'flipped' );\r\n\t\t\t} else {\r\n\t\t\t\tcellElem.classList.add( 'solution-negative', 'user-negative' );\r\n\t\t\t}\r\n\t\t} );\r\n\r\n\t}\r\n\r\n\r\n\t// ######################################################################################\tprivate methods\r\n\r\n\t/**\r\n\t *\r\n\t */\r\n\t_makePuzzlePlayable()\r\n\t{\r\n\t\tconst self     = this,\r\n\t\t\t  table    = self.gridContainer.querySelector( '.nonogram-puzzle-grid' ),\r\n\t\t\t  cells    = self.gridContainer.querySelectorAll( '.nonogram-puzzle-grid td.puzzle-cell' ),\r\n\t\t\t  allCells = self.gridContainer.querySelectorAll( '.nonogram-puzzle-grid td' )\r\n\t\t;\r\n\r\n\t\tself.playerClickMode = 1;\r\n\r\n\t\t// set css classes and event handlers for puzzle cells\r\n\r\n\t\tcells.forEach( ( cellElem ) =>\r\n\t\t{\r\n\t\t\tcellElem.classList.add( 'playable' );\r\n\r\n\t\t\t// highlight row/column on mouse hover\r\n\r\n\t\t\tcellElem.addEventListener( 'mouseenter', ( e ) =>\r\n\t\t\t{\r\n\t\t\t\tconst hoverCell = e.currentTarget,\r\n\t\t\t\t\t  row       = hoverCell.getAttribute( 'data-row' ),\r\n\t\t\t\t\t  column    = hoverCell.getAttribute( 'data-column' )\r\n\t\t\t\t;\r\n\r\n\t\t\t\tallCells.forEach( ( cellElem ) =>\r\n\t\t\t\t{\r\n\t\t\t\t\tif (cellElem.getAttribute( 'data-row' ) === row || cellElem.getAttribute( 'data-column' ) === column) {\r\n\t\t\t\t\t\tcellElem.classList.add( 'row-column-highlight' );\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tcellElem.classList.remove( 'row-column-highlight' );\r\n\t\t\t\t\t}\r\n\t\t\t\t} );\r\n\t\t\t} );\r\n\r\n\t\t\t// mark and store puzzle cell click interactions\r\n\r\n\t\t\tcellElem.addEventListener( 'click', ( e ) =>\r\n\t\t\t{\r\n\t\t\t\tconst cellElem  = e.currentTarget,\r\n\t\t\t\t\t  cellIndex = cellElem.getAttribute( 'data-index' ),\r\n\t\t\t\t\t  cell      = self.puzzle.getCellByIndex( cellIndex )\r\n\t\t\t\t;\r\n\r\n\t\t\t\te.preventDefault();\r\n\r\n\t\t\t\tcell.userSolution = cell.userSolution === self.playerClickMode ? null : self.playerClickMode;\r\n\r\n\t\t\t\ttable.classList.remove( 'solved' );\r\n\t\t\t\tcellElem.classList.remove( 'user-solved', 'user-positive', 'user-negative', 'solution-positive', 'solution-negative' );\r\n\r\n\t\t\t\tif (cell.userSolution === 1) {\r\n\t\t\t\t\tcellElem.classList.add( 'user-solved', 'user-positive' );\r\n\t\t\t\t} else if (cell.userSolution === 0) {\r\n\t\t\t\t\tcellElem.classList.add( 'user-solved', 'user-negative' );\r\n\t\t\t\t}\r\n\r\n\t\t\t\tcellElem.classList.toggle( 'flipped' );\r\n\r\n\t\t\t\tself.drawPreview( 'userSolution' );\r\n\r\n\t\t\t\tif (self.puzzle.checkUserSolution()) {\r\n\t\t\t\t\tself._showPuzzleSolved();\r\n\t\t\t\t}\r\n\t\t\t} );\r\n\t\t} );\r\n\r\n\t\t// remove highlighted cells on puzzle grid mouseout\r\n\r\n\t\ttable.addEventListener( 'mouseleave', () =>\r\n\t\t{\r\n\t\t\tallCells.forEach( ( cellElem ) =>\r\n\t\t\t{\r\n\t\t\t\tcellElem.classList.remove( 'row-column-highlight' );\r\n\t\t\t} );\r\n\t\t} );\r\n\t}\r\n\r\n\r\n\t/**\r\n\t *\r\n\t */\r\n\t_resetPuzzle()\r\n\t{\r\n\t\tconst self      = this,\r\n\t\t\t  cellElems = self.gridContainer.querySelectorAll( '.nonogram-puzzle-grid td.puzzle-cell' )\r\n\t\t;\r\n\r\n\t\t// TODO: uncomment confirm ?\r\n\t\t//if (confirm( 'Are you sure you want to reset the puzzle?' )) {\r\n\r\n\t\tself.gridContainer.classList.remove( 'solved' );\r\n\r\n\t\tself.puzzle.cells.forEach( ( cell ) =>\r\n\t\t{\r\n\t\t\tcell.userSolution = null;\r\n\t\t} );\r\n\r\n\t\tcellElems.forEach( ( cellElem ) =>\r\n\t\t{\r\n\t\t\tcellElem.classList.remove( 'user-solved', 'user-positive', 'user-negative', 'solution-positive', 'solution-negative' );\r\n\t\t} );\r\n\r\n\t\tself.gridContainer.querySelector( '[data-nonogram-preview-grid]' ).innerHTML = '';\r\n\r\n\t\tself.drawPreview( 'userSolution' );\r\n\r\n\t\t//}\r\n\t}\r\n\r\n\r\n\t/**\r\n\t *\r\n\t */\r\n\t_showPuzzleSolved()\r\n\t{\r\n\t\tconst grid = this.gridContainer.querySelector( '.nonogram-puzzle-grid' );\r\n\r\n\t\tgrid.classList.add( 'solved' );\r\n\t}\r\n\r\n\r\n\t/**\r\n\t *\r\n\t * @param name\r\n\t * @returns {Nonogram.GuiTemplate}\r\n\t */\r\n\t_getTemplate( name )\r\n\t{\r\n\t\tconst ret = this.templates.find( ( template ) =>\r\n\t\t{\r\n\t\t\treturn template.name === name;\r\n\t\t} );\r\n\r\n\t\tif (!ret) {\r\n\t\t\tthrow('\"' + name + '\" template not found.');\r\n\t\t}\r\n\r\n\t\treturn ret;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t *\r\n\t * @returns {string}\r\n\t */\r\n\t_resolveThemePath()\r\n\t{\r\n\t\tlet path = '';\r\n\r\n\t\tdocument.querySelectorAll( 'script' ).forEach( ( script ) =>\r\n\t\t{\r\n\t\t\ttry {\r\n\t\t\t\tconst url      = new URL( script.src ),\r\n\t\t\t\t\t  parts    = url.pathname.split( '/' ),\r\n\t\t\t\t\t  fileName = parts.pop()\r\n\t\t\t\t;\r\n\r\n\t\t\t\tif (fileName === 'nonogram.min.js') {\r\n\t\t\t\t\tpath = url.href.replace( fileName, '' ) + 'themes';\r\n\t\t\t\t}\r\n\r\n\t\t\t} catch (err) {\r\n\t\t\t}\r\n\t\t} );\r\n\r\n\t\treturn path;\r\n\t}\r\n\r\n\r\n};\r\n\r\n\n\n//# sourceURL=webpack://Nonogram/./src/nonogram/gui.js?");

/***/ }),

/***/ "./src/nonogram/nonogram.js":
/*!**********************************!*\
  !*** ./src/nonogram/nonogram.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/* eslint-disable no-unused-vars */\r\n/**\r\n *\r\n * @type {{Puzzle: Nonogram.Puzzle, Utility: Nonogram.Utility, Solver: Nonogram.Solver, PuzzleCell: Nonogram.PuzzleCell, PuzzleLine: Nonogram.PuzzleLine, Creator: Nonogram.Creator, Gui: Nonogram.Gui, GuiTemplate: Nonogram.GuiTemplate}}\r\n * @this Nonogram\r\n *\r\n * the global namespace for the nonogram package\r\n *\r\n * @property {string} version\r\n * @property {class} Puzzle\r\n * @property {class} PuzzleCell\r\n * @property {class} PuzzleLine\r\n * @property {class} Utility\r\n * @property {class} Solver\r\n * @property {class} Gui\r\n */\r\nconst Nonogram = {\r\n\tversion: '1.0.0'\r\n};\r\n\r\n\r\n// export default Nonogram;\n\n//# sourceURL=webpack://Nonogram/./src/nonogram/nonogram.js?");

/***/ }),

/***/ "./src/nonogram/puzzle-cell.js":
/*!*************************************!*\
  !*** ./src/nonogram/puzzle-cell.js ***!
  \*************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _nonogram__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./nonogram */ \"./src/nonogram/nonogram.js\");\n/* harmony import */ var _nonogram__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nonogram__WEBPACK_IMPORTED_MODULE_0__);\n\r\n\r\n\r\n/**\r\n * @class\r\n * @type {Nonogram.PuzzleCell}\r\n * @this Nonogram.PuzzleCell\r\n *\r\n * a container representing a single cell in the puzzle grid\r\n *\r\n * @property {number} this.index\r\n * @property {number} this.column\r\n * @property {number} this.row\r\n * @property {number|null} this.solution\r\n * @property {number|null} this.userSolution\r\n * @property {number|null} this.aiSolution\r\n */\r\n_nonogram__WEBPACK_IMPORTED_MODULE_0___default.a.PuzzleCell = class\r\n{\r\n\tconstructor( params )\r\n\t{\r\n\t\tthis.index        = null;\r\n\t\tthis.column       = null;\r\n\t\tthis.row          = null;\r\n\t\tthis.solution     = null;\r\n\t\tthis.userSolution = null;\r\n\t\tthis.aiSolution   = null;\r\n\r\n\t\tObject.assign( this, params );\r\n\t}\r\n};\r\n\n\n//# sourceURL=webpack://Nonogram/./src/nonogram/puzzle-cell.js?");

/***/ }),

/***/ "./src/nonogram/puzzle-line.js":
/*!*************************************!*\
  !*** ./src/nonogram/puzzle-line.js ***!
  \*************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _nonogram__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./nonogram */ \"./src/nonogram/nonogram.js\");\n/* harmony import */ var _nonogram__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nonogram__WEBPACK_IMPORTED_MODULE_0__);\n\r\n\r\n\r\n/**\r\n * @class\r\n * @type {Nonogram.PuzzleLine}\r\n * @this Nonogram.PuzzleLine\r\n *\r\n * a container representing a complete row or column of grid cells\r\n *\r\n * @property {string} this.type - either 'row' or 'column'\r\n * @property {number} this.index - the column or row index\r\n * @property {number} this.length\r\n * @property {number} this.minimumSectionLength\r\n * @property {array} this.sections\r\n * @property {array} this.cells\r\n * @property {boolean} this.solved\r\n */\r\n_nonogram__WEBPACK_IMPORTED_MODULE_0___default.a.PuzzleLine = class\r\n{\r\n\tconstructor( params )\r\n\t{\r\n\t\tthis.type                 = null;\r\n\t\tthis.index                = null;\r\n\t\tthis.length               = null;\r\n\t\tthis.minimumSectionLength = 0;\r\n\t\tthis.sections             = [];\r\n\t\tthis.cells                = [];\r\n\t\tthis.solved               = false;\r\n\r\n\t\tObject.assign( this, params );\r\n\t}\r\n};\r\n\r\n\r\n\n\n//# sourceURL=webpack://Nonogram/./src/nonogram/puzzle-line.js?");

/***/ }),

/***/ "./src/nonogram/puzzle.js":
/*!********************************!*\
  !*** ./src/nonogram/puzzle.js ***!
  \********************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _nonogram__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./nonogram */ \"./src/nonogram/nonogram.js\");\n/* harmony import */ var _nonogram__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nonogram__WEBPACK_IMPORTED_MODULE_0__);\n\r\n\r\n\r\n/**\r\n * @class\r\n * @type {Nonogram.Puzzle}\r\n * @this Nonogram.Puzzle\r\n *\r\n * the main puzzle class containing the grid of cells, row/column hints, etc.\r\n *\r\n * @property {number} this.width\r\n * @property {number} this.height\r\n * @property {number} this.totalCells\r\n * @property {array} this.cells\r\n * @property {array} this.rowHints\r\n * @property {array} this.columnHints\r\n * @property {Nonogram.Creator|null} creator\r\n * @property {array} this.grid - a multi-dimensional array representing rows and columns.\r\n *                   for example a 2x2 grid could be represented by [[0,1],[0,0]]\r\n */\r\n_nonogram__WEBPACK_IMPORTED_MODULE_0___default.a.Puzzle = class\r\n{\r\n\t/**\r\n\t * @param {number} width - an integer >= 1 specifying the number of rows\r\n\t * @param {number} height - an integer >= 1 specifying the number of columns\r\n\t */\r\n\tconstructor( width, height )\r\n\t{\r\n\t\tif ((width <= 0 || height <= 0) || (width === 1 && height === 1)) {\r\n\t\t\tthrow('invalid dimensions: ' + width.toString() + ' x ' + height.toString());\r\n\t\t}\r\n\r\n\t\tthis.width      = typeof width === 'number' ? width : parseInt( width.toString(), 10 );\r\n\t\tthis.height     = typeof height === 'number' ? height : parseInt( height.toString(), 10 );\r\n\t\tthis.totalCells = this.width * this.height;\r\n\r\n\t\tthis.reset();\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * empty all arrays and create zero-filled multidimensional grid array\r\n\t */\r\n\treset()\r\n\t{\r\n\t\tconst zeroFill = _nonogram__WEBPACK_IMPORTED_MODULE_0___default.a.Utility.getZeroFilledArray;\r\n\r\n\t\tthis.creator     = null;\r\n\t\tthis.cells       = [];\r\n\t\tthis.rowHints    = [];\r\n\t\tthis.columnHints = [];\r\n\t\tthis.grid        = zeroFill( this.height ).map( () =>\r\n\t\t{\r\n\t\t\treturn zeroFill( this.width );\r\n\t\t} );\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * - accepts a multidimensional array\r\n\t *\r\n\t * @param {array} grid\r\n\t */\r\n\tcreateFromGrid( grid )\r\n\t{\r\n\t\tconst self = this;\r\n\t\tlet columnHints, row, columnKey, cell, currentVal, lastVal;\r\n\r\n\t\tself.reset();\r\n\r\n\t\tself.grid = grid;\r\n\r\n\t\t// populate cells array\r\n\r\n\t\tself.grid.forEach( function ( row, rowKey )\r\n\t\t{\r\n\t\t\trow.forEach( function ( column, columnKey )\r\n\t\t\t{\r\n\t\t\t\tself.cells.push( new _nonogram__WEBPACK_IMPORTED_MODULE_0___default.a.PuzzleCell( {\r\n\t\t\t\t\tindex:    (rowKey * self.width) + columnKey,\r\n\t\t\t\t\tcolumn:   columnKey,\r\n\t\t\t\t\trow:      rowKey,\r\n\t\t\t\t\tsolution: column\r\n\t\t\t\t} ) );\r\n\t\t\t} );\r\n\t\t} );\r\n\r\n\r\n\t\t// populate row hints\r\n\t\tself.grid.forEach( ( row, rowKey ) =>\r\n\t\t{\r\n\t\t\tlet rowHints = [];\r\n\r\n\t\t\tself.rowHints[rowKey] = [];\r\n\r\n\t\t\trow.forEach( ( column, columnKey ) =>\r\n\t\t\t{\r\n\t\t\t\tconst currentVal = column,\r\n\t\t\t\t\t  lastVal    = columnKey > 0 ? self.grid[rowKey][columnKey - 1] : 0\r\n\t\t\t\t;\r\n\r\n\t\t\t\tif (currentVal === 1 && lastVal === 0) {\r\n\t\t\t\t\trowHints.push( 1 );\r\n\t\t\t\t} else if (currentVal === 0 && lastVal === 1) {\r\n\t\t\t\t\trowHints.push( 0 );\r\n\t\t\t\t} else if (currentVal === 1 && lastVal === 1) {\r\n\t\t\t\t\trowHints[rowHints.length - 1]++;\r\n\t\t\t\t}\r\n\t\t\t} );\r\n\r\n\t\t\t// clean up row hints\r\n\t\t\trowHints.forEach( ( hint ) =>\r\n\t\t\t{\r\n\t\t\t\tif (hint > 0) {\r\n\t\t\t\t\tself.rowHints[rowKey].push( hint );\r\n\t\t\t\t}\r\n\t\t\t} );\r\n\t\t} );\r\n\r\n\t\t// populate column hints\r\n\r\n\t\tfor (columnKey = 0; columnKey < self.width; columnKey++) {\r\n\r\n\t\t\tself.columnHints[columnKey] = [];\r\n\t\t\tcolumnHints                 = [];\r\n\r\n\t\t\tfor (cell = columnKey; cell < self.totalCells; cell += self.width) {\r\n\r\n\t\t\t\trow        = Math.floor( cell / self.width );\r\n\t\t\t\tcurrentVal = self.grid[row][columnKey];\r\n\t\t\t\tlastVal    = row > 0 ? self.grid[row - 1][columnKey] : 0;\r\n\r\n\t\t\t\tif (currentVal === 1 && lastVal === 0) {\r\n\t\t\t\t\tcolumnHints.push( 1 );\r\n\t\t\t\t} else if (currentVal === 0 && lastVal === 1) {\r\n\t\t\t\t\tcolumnHints.push( 0 );\r\n\t\t\t\t} else if (currentVal === 1 && lastVal === 1) {\r\n\t\t\t\t\tcolumnHints[columnHints.length - 1]++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// clean up column hints\r\n\t\t\tcolumnHints.forEach( ( hint ) =>\r\n\t\t\t{\r\n\t\t\t\tif (hint > 0) {\r\n\t\t\t\t\tself.columnHints[columnKey].push( hint );\r\n\t\t\t\t}\r\n\t\t\t} );\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t// noinspection JSUnusedGlobalSymbols\r\n\t/**\r\n\t * @param {object} hints\r\n\t * @param {array} hints.row\r\n\t * @param {array} hints.column\r\n\t */\r\n\tcreateFromHints( hints )\r\n\t{\r\n\t\tconst self = this;\r\n\r\n\t\tself.reset();\r\n\r\n\t\tself.rowHints    = hints.row;\r\n\t\tself.columnHints = hints.column;\r\n\r\n\t\t// populate cells array\r\n\r\n\t\tself.grid.forEach( ( row, rowKey ) =>\r\n\t\t{\r\n\t\t\trow.forEach( ( column, columnKey ) =>\r\n\t\t\t{\r\n\t\t\t\tself.cells.push( new _nonogram__WEBPACK_IMPORTED_MODULE_0___default.a.PuzzleCell( {\r\n\t\t\t\t\tindex:  (rowKey * self.width) + columnKey,\r\n\t\t\t\t\tcolumn: columnKey,\r\n\t\t\t\t\trow:    rowKey\r\n\t\t\t\t} ) );\r\n\t\t\t} );\r\n\t\t} );\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * @returns {boolean}\r\n\t */\r\n\tcheckUserSolution()\r\n\t{\r\n\t\treturn this.cells.every( ( cell ) =>\r\n\t\t{\r\n\t\t\t// cell.solution will be 0 or 1, but cell.userSolution might be null, 0 or 1\r\n\t\t\tconst userValue = cell.userSolution === 1 ? 1 : 0;\r\n\r\n\t\t\treturn cell.solution === userValue;\r\n\t\t} );\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * @param {number} row\r\n\t * @returns {array|boolean}\r\n\t */\r\n\tgetRowCells( row )\r\n\t{\r\n\t\tconst self  = this,\r\n\t\t\t  cells = [];\r\n\r\n\t\tself.cells.forEach( ( cell ) =>\r\n\t\t{\r\n\t\t\tif (cell.row === row) {\r\n\t\t\t\tcells.push( cell );\r\n\t\t\t}\r\n\t\t} );\r\n\r\n\t\treturn cells.length > 0 ? cells : false;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * @param {number} column\r\n\t * @returns {array|boolean}\r\n\t */\r\n\tgetColumnCells( column )\r\n\t{\r\n\t\tconst self  = this,\r\n\t\t\t  cells = [];\r\n\r\n\t\tself.cells.forEach( ( cell ) =>\r\n\t\t{\r\n\t\t\tif (cell.column === column) {\r\n\t\t\t\tcells.push( cell );\r\n\t\t\t}\r\n\t\t} );\r\n\r\n\t\treturn cells.length > 0 ? cells : false;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * @param {number|string} index\r\n\t * @returns {object|boolean}\r\n\t */\r\n\tgetCellByIndex( index )\r\n\t{\r\n\t\tconst indexInt = typeof index !== 'number' ? parseInt( index, 10 ) : index;\r\n\r\n\t\treturn this.cells[indexInt] ? this.cells[indexInt] : false;\r\n\t}\r\n\r\n};\r\n\r\n\r\n\r\n\n\n//# sourceURL=webpack://Nonogram/./src/nonogram/puzzle.js?");

/***/ }),

/***/ "./src/nonogram/solver.js":
/*!********************************!*\
  !*** ./src/nonogram/solver.js ***!
  \********************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _nonogram__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./nonogram */ \"./src/nonogram/nonogram.js\");\n/* harmony import */ var _nonogram__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nonogram__WEBPACK_IMPORTED_MODULE_0__);\n\r\n\r\n\r\n/**\r\n * @class\r\n * @type {Nonogram.Solver}\r\n * @this Nonogram.Solver\r\n *\r\n * a class that solves nonogram puzzles using logical techniques a human might use\r\n *\r\n * @property {Nonogram.Puzzle} this.puzzle\r\n * @property {boolean} this.isReset\r\n * @property {array} this.lines\r\n * @property {array} this.solutionLog\r\n */\r\n_nonogram__WEBPACK_IMPORTED_MODULE_0___default.a.Solver = class\r\n{\r\n\r\n\t/**\r\n\t * @param {Nonogram.Puzzle} puzzle\r\n\t */\r\n\tconstructor( puzzle )\r\n\t{\r\n\t\tthis.puzzle = puzzle;\r\n\r\n\t\tthis.reset();\r\n\t}\r\n\r\n\r\n\t/**\r\n\t *\r\n\t * @returns {boolean}\r\n\t */\r\n\tsolve()\r\n\t{\r\n\t\tconst self       = this,\r\n\t\t\t  start      = new Date().getTime()\r\n\t\t;\r\n\t\tlet lastProgress = -1,\r\n\t\t\tpass         = 1,\r\n\t\t\tsolved, passStart, passEnd, end, passElapsedTime, totalElapsedTime\r\n\t\t;\r\n\r\n\t\tif (!self.isReset) {\r\n\t\t\tself.reset();\r\n\t\t}\r\n\r\n\t\tself.isReset = false;\r\n\t\tself.log( 'Starting solve algorithm', 'info' );\r\n\r\n\r\n\t\twhile (self.getProgress() > lastProgress && self.getTotalSolved() < self.puzzle.cells.length) {\r\n\r\n\t\t\tpassStart    = new Date().getTime();\r\n\t\t\tlastProgress = self.getProgress();\r\n\r\n\t\t\tself.lines.forEach( ( line ) =>\r\n\t\t\t{\r\n\t\t\t\tif (!line.solved) {\r\n\t\t\t\t\tself.eliminateImpossibleFits( line );\r\n\t\t\t\t\tself.findKnownPositivesAndNegatives( line );\r\n\t\t\t\t\tself.findSectionDefiningChains( line );\r\n\t\t\t\t\tself.findAnchoredSections( line );\r\n\t\t\t\t\tself.findCompletedSections( line );\r\n\t\t\t\t\tself.findCompletedLines( line );\r\n\t\t\t\t}\r\n\t\t\t} );\r\n\r\n\t\t\tpassEnd         = new Date().getTime();\r\n\t\t\tpassElapsedTime = (passEnd - passStart) / 1000;\r\n\r\n\t\t\tself.log( 'Pass ' + pass + ' completed in ' + passElapsedTime + ' seconds :: '\r\n\t\t\t\t+ self.getTotalSolved() + '/' + self.puzzle.cells.length + ' cells solved', 'info'\r\n\t\t\t);\r\n\t\t\tpass++;\r\n\t\t}\r\n\r\n\t\tsolved           = self.getTotalSolved() === self.puzzle.cells.length;\r\n\t\tend              = new Date().getTime();\r\n\t\ttotalElapsedTime = (end - start) / 1000;\r\n\r\n\t\tself.log( 'Solve algorithm finished in ' + totalElapsedTime + ' seconds.', 'info' );\r\n\r\n\t\tif (solved) {\r\n\t\t\tself.log( 'Solution Found.', 'success' );\r\n\t\t} else {\r\n\t\t\tself.log( 'Could not find solution.', 'failure' );\r\n\t\t}\r\n\r\n\t\treturn solved;\r\n\t}\r\n\r\n\r\n\t//\t#############################################################################################\tsolution algorithms\r\n\r\n\t/**\r\n\t *\r\n\t * @param {Nonogram.PuzzleLine} line\r\n\t */\r\n\teliminateImpossibleFits( line )\r\n\t{\r\n\t\tconst self            = this;\r\n\t\tlet minimumStartIndex = 0,\r\n\t\t\tmaximumStartIndex = line.length - line.minimumSectionLength,\r\n\t\t\ti;\r\n\r\n\r\n\t\t// no sections\r\n\r\n\t\tif (line.sections.length === 0) {\r\n\r\n\t\t\tline.cells.forEach( ( cell ) =>\r\n\t\t\t{\r\n\t\t\t\tself.setCellSolution( cell, 0 );\r\n\t\t\t} );\r\n\t\t}\r\n\r\n\t\t// tighten range if one or more known negative cells start the line\r\n\r\n\t\tfor (i = 0; i < line.length; i++) {\r\n\t\t\tif (line.cells[i].aiSolution === 0) {\r\n\t\t\t\tminimumStartIndex++;\r\n\t\t\t} else {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// tighten range if one or more known negative cells end the line\r\n\r\n\t\tfor (i = line.length - 1; i >= 0; i--) {\r\n\t\t\tif (line.cells[i].aiSolution === 0) {\r\n\t\t\t\tmaximumStartIndex--;\r\n\t\t\t} else {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tline.sections.forEach( ( section ) =>\r\n\t\t{\r\n\t\t\tlet newPossibleStartIndexes = _nonogram__WEBPACK_IMPORTED_MODULE_0___default.a.Utility.cloneArray( section.possibleStartIndexes );\r\n\r\n\t\t\t// eliminate places where section does not fit\r\n\r\n\t\t\tsection.possibleStartIndexes.forEach( ( possibleStartIndex ) =>\r\n\t\t\t{\r\n\t\t\t\tconst testCell = line.cells[possibleStartIndex + section.length];\r\n\t\t\t\tlet end;\r\n\r\n\t\t\t\t// the total length of all sections including minimum gap(s) of one cell does not allow this section to fit:\r\n\r\n\t\t\t\tif (possibleStartIndex < minimumStartIndex || possibleStartIndex > maximumStartIndex) {\r\n\t\t\t\t\tnewPossibleStartIndexes = _nonogram__WEBPACK_IMPORTED_MODULE_0___default.a.Utility.removeFromArray( newPossibleStartIndexes, possibleStartIndex );\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// there is a known positive cell immediately following the possible section placement, so section cannot start here\r\n\r\n\t\t\t\tif (testCell && testCell.aiSolution === 1) {\r\n\t\t\t\t\tnewPossibleStartIndexes = _nonogram__WEBPACK_IMPORTED_MODULE_0___default.a.Utility.removeFromArray( newPossibleStartIndexes, possibleStartIndex );\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// there is a known impossible cell in this range, so section cannot fit here:\r\n\r\n\t\t\t\tend = possibleStartIndex + section.length - 1;\r\n\t\t\t\tend = (end > line.length - 1) ? line.length - 1 : end;\r\n\r\n\t\t\t\tfor (i = possibleStartIndex; i <= end; i++) {\r\n\t\t\t\t\tif (i > line.length - 1 || line.cells[i].aiSolution === 0) {\r\n\t\t\t\t\t\tnewPossibleStartIndexes = _nonogram__WEBPACK_IMPORTED_MODULE_0___default.a.Utility.removeFromArray( newPossibleStartIndexes, possibleStartIndex );\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} );\r\n\r\n\t\t\tminimumStartIndex += section.length + 1;\r\n\t\t\tmaximumStartIndex += section.length + 1;\r\n\r\n\t\t\tsection.possibleStartIndexes = newPossibleStartIndexes;\r\n\t\t} );\r\n\t}\r\n\r\n\r\n\t/**\r\n\t *\r\n\t * @param {Nonogram.PuzzleLine} line\r\n\t */\r\n\tfindKnownPositivesAndNegatives( line )\r\n\t{\r\n\t\tconst totalCellCounts = _nonogram__WEBPACK_IMPORTED_MODULE_0___default.a.Utility.getZeroFilledArray( line.length );\r\n\r\n\r\n\t\tline.sections.forEach( ( section ) =>\r\n\t\t{\r\n\t\t\tconst cellCounts = _nonogram__WEBPACK_IMPORTED_MODULE_0___default.a.Utility.getZeroFilledArray( line.length );\r\n\r\n\t\t\t// keep two counts: 1) all common cells for this section, and 2) cells where no section can be\r\n\r\n\t\t\tsection.possibleStartIndexes.forEach( ( possibleStartIndex ) =>\r\n\t\t\t{\r\n\t\t\t\tconst start = possibleStartIndex,\r\n\t\t\t\t\t  end   = start + section.length - 1\r\n\t\t\t\t;\r\n\t\t\t\tlet i;\r\n\r\n\t\t\t\tfor (i = start; i <= end; i++) {\r\n\t\t\t\t\tcellCounts[i]++;\r\n\t\t\t\t\ttotalCellCounts[i]++;\r\n\t\t\t\t}\r\n\t\t\t} );\r\n\r\n\t\t\t// common to all possibilities, solve as positive\r\n\r\n\t\t\tcellCounts.forEach( ( cellCount, cellCountKey ) =>\r\n\t\t\t{\r\n\t\t\t\tconst cell = line.cells[cellCountKey];\r\n\r\n\t\t\t\tif (cell && cell.aiSolution === null && cellCount === section.possibleStartIndexes.length) {\r\n\t\t\t\t\tthis.setCellSolution( cell, 1 );\r\n\t\t\t\t}\r\n\t\t\t} );\r\n\t\t} );\r\n\r\n\t\t// no possible cells, remove as a possibility\r\n\r\n\t\ttotalCellCounts.forEach( ( cellCount, cellCountKey ) =>\r\n\t\t{\r\n\t\t\tconst cell = line.cells[cellCountKey];\r\n\r\n\t\t\tif (cell && cell.aiSolution === null && cellCount === 0) {\r\n\t\t\t\tthis.setCellSolution( cell, 0 );\r\n\t\t\t}\r\n\t\t} );\r\n\t}\r\n\r\n\r\n\t/**\r\n\t *\r\n\t * @param {Nonogram.PuzzleLine} line\r\n\t */\r\n\tfindAnchoredSections( line )\r\n\t{\r\n\t\tlet i, fillRange, firstSection, lastSection;\r\n\r\n\r\n\t\tif (line.sections.length > 0) {\r\n\r\n\t\t\tfirstSection = line.sections[0];\r\n\t\t\tlastSection  = line.sections[line.sections.length - 1];\r\n\r\n\t\t\t// find sections anchored to start of line\r\n\r\n\t\t\tfillRange = null;\r\n\r\n\t\t\tfor (i = 0; i < line.cells.length; i++) {\r\n\t\t\t\tif (line.cells[i].aiSolution === null) {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t} else if (line.cells[i].aiSolution === 1) {\r\n\t\t\t\t\tfillRange = [i, i + firstSection.length - 1];\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (fillRange !== null) {\r\n\t\t\t\tfor (i = fillRange[0]; i <= fillRange[1]; i++) {\r\n\t\t\t\t\tif (line.cells[i]) {\r\n\t\t\t\t\t\tthis.setCellSolution( line.cells[i], 1 );\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (line.cells[i]) {\r\n\t\t\t\t\tthis.setCellSolution( line.cells[i], 0 );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// find sections anchored to end of line\r\n\r\n\t\t\tfillRange = null;\r\n\r\n\t\t\tfor (i = line.cells.length - 1; i >= 0; i--) {\r\n\t\t\t\tif (line.cells[i].aiSolution === null) {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t} else if (line.cells[i].aiSolution === 1) {\r\n\t\t\t\t\tfillRange = [i - lastSection.length + 1, i];\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (fillRange !== null) {\r\n\t\t\t\tfor (i = fillRange[0]; i <= fillRange[1]; i++) {\r\n\t\t\t\t\tif (line.cells[i]) {\r\n\t\t\t\t\t\tthis.setCellSolution( line.cells[i], 1 );\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (line.cells[fillRange[0] - 1]) {\r\n\t\t\t\t\tthis.setCellSolution( line.cells[fillRange[0] - 1], 0 );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t/**\r\n\t *\r\n\t * @param {Nonogram.PuzzleLine} line\r\n\t */\r\n\tfindSectionDefiningChains( line )\r\n\t{\r\n\t\tconst self    = this;\r\n\t\tlet chains    = [],\r\n\t\t\tlastValue = 0,\r\n\t\t\tchain, sectionsSorted, firstSortedSection\r\n\t\t;\r\n\r\n\r\n\t\t// sort sections by highest length to lowest\r\n\r\n\t\tsectionsSorted     = _nonogram__WEBPACK_IMPORTED_MODULE_0___default.a.Utility.cloneArray( line.sections ).sort( function ( a, b )\r\n\t\t{\r\n\t\t\treturn a.length > b.length ? -1 : 1;\r\n\t\t} );\r\n\t\tfirstSortedSection = sectionsSorted[0];\r\n\r\n\r\n\t\t// loop through all cells, creating array of connectors\r\n\r\n\t\tline.cells.forEach( ( cell, cellKey ) =>\r\n\t\t{\r\n\t\t\tif (cell.aiSolution === 1) {\r\n\t\t\t\tif (lastValue !== 1) {\r\n\t\t\t\t\tchain = {\r\n\t\t\t\t\t\tstart:  cellKey,\r\n\t\t\t\t\t\tlength: 1\r\n\t\t\t\t\t};\r\n\t\t\t\t\tchains.push( chain );\r\n\t\t\t\t} else {\r\n\t\t\t\t\tchain.length++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tlastValue = cell.aiSolution;\r\n\t\t} );\r\n\r\n\r\n\t\t// if a connector is found with the first section's length, place negatives around it and mark the section as complete & continue\r\n\r\n\t\tchains.forEach( ( chain ) =>\r\n\t\t{\r\n\t\t\tif (chain.length === firstSortedSection.length) {\r\n\r\n\t\t\t\tif (line.cells[chain.start - 1]) {\r\n\t\t\t\t\tself.setCellSolution( line.cells[chain.start - 1], 0 );\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (line.cells[chain.start + firstSortedSection.length]) {\r\n\t\t\t\t\tself.setCellSolution( line.cells[chain.start + firstSortedSection.length], 0 );\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfirstSortedSection.solved = true;\r\n\t\t\t}\r\n\t\t} );\r\n\t}\r\n\r\n\r\n\t/**\r\n\t *\r\n\t * @param {Nonogram.PuzzleLine} line\r\n\t */\r\n\tfindCompletedSections( line )\r\n\t{\r\n\t\t// complete lines where all sections have been found\r\n\r\n\t\tline.sections.forEach( ( section ) =>\r\n\t\t{\r\n\t\t\tlet firstNegative, lastNegative;\r\n\r\n\t\t\tif (!section.solved) {\r\n\r\n\t\t\t\t// only one possible place...\r\n\r\n\t\t\t\tif (section.possibleStartIndexes.length === 1) {\r\n\r\n\t\t\t\t\t// make sure there is a negative cell on either side of the section\r\n\r\n\t\t\t\t\tfirstNegative = section.possibleStartIndexes[0] - 1;\r\n\t\t\t\t\tlastNegative  = section.possibleStartIndexes[0] + section.length;\r\n\r\n\t\t\t\t\tif (line.cells[firstNegative] && line.cells[firstNegative].aiSolution === null) {\r\n\t\t\t\t\t\tthis.setCellSolution( line.cells[firstNegative], 0 );\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (line.cells[lastNegative] && line.cells[lastNegative].aiSolution === null) {\r\n\t\t\t\t\t\tthis.setCellSolution( line.cells[lastNegative], 0 );\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tsection.solved = true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} );\r\n\t}\r\n\r\n\r\n\t/**\r\n\t *\r\n\t * @param {Nonogram.PuzzleLine} line\r\n\t */\r\n\tfindCompletedLines( line )\r\n\t{\r\n\t\tlet totalSectionLength  = 0,\r\n\t\t\ttotalPositiveSolved = 0\r\n\t\t;\r\n\r\n\t\t// complete lines where all sections have been found\r\n\r\n\t\tline.sections.forEach( ( section ) =>\r\n\t\t{\r\n\t\t\ttotalSectionLength += section.length;\r\n\t\t} );\r\n\r\n\t\tline.cells.forEach( ( cell ) =>\r\n\t\t{\r\n\t\t\ttotalPositiveSolved += cell.aiSolution === 1;\r\n\t\t} );\r\n\r\n\t\tif (totalSectionLength === totalPositiveSolved) {\r\n\r\n\t\t\tline.cells.forEach( ( cell ) =>\r\n\t\t\t{\r\n\t\t\t\tif (cell.aiSolution === null) {\r\n\t\t\t\t\tthis.setCellSolution( cell, 0 );\r\n\t\t\t\t}\r\n\t\t\t} );\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t//\t#############################################################################################\tother methods\r\n\r\n\r\n\t/**\r\n\t *\r\n\t */\r\n\treset()\r\n\t{\r\n\t\tconst self                  = this,\r\n\t\t\t  possibleRowIndexes    = [],\r\n\t\t\t  possibleColumnIndexes = [];\r\n\t\tlet i;\r\n\r\n\t\tself.isReset     = true;\r\n\t\tself.solutionLog = [];\r\n\t\tself.lines       = [];\r\n\r\n\t\tthis.log( 'Resetting variables', 'info' );\r\n\r\n\t\tself.puzzle.cells.forEach( ( cell ) =>\r\n\t\t{\r\n\t\t\tcell.aiSolution = null;\r\n\t\t} );\r\n\r\n\t\tfor (i = 0; i < self.puzzle.width; i++) {\r\n\t\t\tpossibleRowIndexes.push( i );\r\n\t\t}\r\n\r\n\t\tfor (i = 0; i < self.puzzle.height; i++) {\r\n\t\t\tpossibleColumnIndexes.push( i );\r\n\t\t}\r\n\r\n\t\tself.puzzle.rowHints.forEach( ( rowHint, rowNumber ) =>\r\n\t\t{\r\n\t\t\tlet line = new _nonogram__WEBPACK_IMPORTED_MODULE_0___default.a.PuzzleLine( {\r\n\t\t\t\ttype:   'row',\r\n\t\t\t\tindex:  rowNumber,\r\n\t\t\t\tlength: self.puzzle.width,\r\n\t\t\t\tcells:  self.puzzle.getRowCells( rowNumber )\r\n\t\t\t} );\r\n\r\n\t\t\trowHint.forEach( ( len, index ) =>\r\n\t\t\t{\r\n\t\t\t\tline.sections.push( {\r\n\t\t\t\t\tindex:                index,\r\n\t\t\t\t\tlength:               len,\r\n\t\t\t\t\tpossibleStartIndexes: possibleRowIndexes,\r\n\t\t\t\t\tknownIndexes:         [],\r\n\t\t\t\t\tsolved:               false\r\n\t\t\t\t} );\r\n\r\n\t\t\t\tline.minimumSectionLength += len + 1;\r\n\t\t\t} );\r\n\r\n\t\t\tline.minimumSectionLength--;\r\n\r\n\t\t\tself.lines.push( line );\r\n\t\t} );\r\n\r\n\r\n\t\tself.puzzle.columnHints.forEach( ( columnHint, columnKey ) =>\r\n\t\t{\r\n\t\t\tlet line = new _nonogram__WEBPACK_IMPORTED_MODULE_0___default.a.PuzzleLine( {\r\n\t\t\t\ttype:   'column',\r\n\t\t\t\tindex:  columnKey,\r\n\t\t\t\tlength: this.puzzle.height,\r\n\t\t\t\tcells:  this.puzzle.getColumnCells( columnKey ),\r\n\t\t\t} );\r\n\r\n\t\t\tcolumnHint.forEach( ( len, index ) =>\r\n\t\t\t{\r\n\r\n\t\t\t\tline.sections.push( {\r\n\t\t\t\t\tindex:                index,\r\n\t\t\t\t\tlength:               len,\r\n\t\t\t\t\tpossibleStartIndexes: possibleColumnIndexes,\r\n\t\t\t\t\tknownIndexes:         [],\r\n\t\t\t\t\tsolved:               false\r\n\t\t\t\t} );\r\n\r\n\t\t\t\tline.minimumSectionLength += len + 1;\r\n\t\t\t} );\r\n\r\n\t\t\tline.minimumSectionLength--;\r\n\r\n\t\t\tself.lines.push( line );\r\n\t\t} );\r\n\t}\r\n\r\n\r\n\t/**\r\n\t *\r\n\t * @param {Nonogram.PuzzleCell} puzzleCell\r\n\t * @param {number} value\r\n\t */\r\n\tsetCellSolution( puzzleCell, value )\r\n\t{\r\n\t\tif (puzzleCell.aiSolution !== null) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tthis.lines.forEach( ( line ) =>\r\n\t\t{\r\n\t\t\tconst isRow     = line.type === 'row' && line.index === puzzleCell.row,\r\n\t\t\t\t  isCol     = line.type === 'column' && line.index === puzzleCell.column\r\n\t\t\t;\r\n\t\t\tlet cellsSolved = 0;\r\n\r\n\t\t\tif (isRow || isCol) {\r\n\r\n\t\t\t\tline.cells.forEach( ( cell ) =>\r\n\t\t\t\t{\r\n\t\t\t\t\tif (cell.index === puzzleCell.index) {\r\n\t\t\t\t\t\tcell.aiSolution = value;\r\n\t\t\t\t\t\tcellsSolved++;\r\n\t\t\t\t\t} else if (cell.aiSolution !== null) {\r\n\t\t\t\t\t\tcellsSolved++;\r\n\t\t\t\t\t}\r\n\t\t\t\t} );\r\n\r\n\t\t\t\tif (cellsSolved === line.length) {\r\n\t\t\t\t\tline.solved = true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} );\r\n\t}\r\n\r\n\r\n\t/**\r\n\t *\r\n\t * @param html\r\n\t * @param cssClass\r\n\t */\r\n\tlog( html, cssClass )\r\n\t{\r\n\t\tthis.solutionLog.push( {\r\n\t\t\thtml:     html,\r\n\t\t\tcssClass: cssClass\r\n\t\t} );\r\n\t}\r\n\r\n\r\n\t/**\r\n\t *\r\n\t * @returns {number}\r\n\t */\r\n\tgetTotalSolved()\r\n\t{\r\n\t\tlet total = 0;\r\n\r\n\t\tthis.puzzle.cells.forEach( ( cell ) =>\r\n\t\t{\r\n\t\t\ttotal += cell.aiSolution !== null;\r\n\t\t} );\r\n\r\n\t\treturn total;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * - calculate the maximum # of possible permutations, depending on the current state of the solving process.\r\n\t *\r\n\t * @returns {number}\r\n\t */\r\n\tgetProgress()\r\n\t{\r\n\t\tconst self             = this;\r\n\t\tlet maxPossibilities   = 0,\r\n\t\t\ttotalPossibilities = 0\r\n\t\t;\r\n\r\n\t\tself.lines.forEach( ( line ) =>\r\n\t\t{\r\n\t\t\tmaxPossibilities += line.sections.length * (line.type === 'row' ? this.puzzle.width : this.puzzle.height);\r\n\r\n\t\t\tline.sections.forEach( ( section ) =>\r\n\t\t\t{\r\n\t\t\t\ttotalPossibilities += section.possibleStartIndexes.length;\r\n\t\t\t} );\r\n\t\t} );\r\n\r\n\t\treturn maxPossibilities - totalPossibilities;\r\n\t}\r\n\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n\n//# sourceURL=webpack://Nonogram/./src/nonogram/solver.js?");

/***/ }),

/***/ "./src/nonogram/utility.js":
/*!*********************************!*\
  !*** ./src/nonogram/utility.js ***!
  \*********************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _nonogram__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./nonogram */ \"./src/nonogram/nonogram.js\");\n/* harmony import */ var _nonogram__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nonogram__WEBPACK_IMPORTED_MODULE_0__);\n\r\n\r\n\r\n/**\r\n * @class\r\n * @type {Nonogram.Utility}\r\n * @this Nonogram.Utility\r\n */\r\n_nonogram__WEBPACK_IMPORTED_MODULE_0___default.a.Utility = class\r\n{\r\n\t/**\r\n\t *\r\n\t * @param array\r\n\t * @param value\r\n\t * @returns {array}\r\n\t */\r\n\tstatic removeFromArray( array, value )\r\n\t{\r\n\t\tconst index = array.indexOf( value );\r\n\r\n\t\tif (index !== -1) {\r\n\t\t\tarray.splice( index, 1 );\r\n\t\t}\r\n\r\n\t\treturn array;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t *\r\n\t * @param length\r\n\t * @returns {array}\r\n\t */\r\n\tstatic getZeroFilledArray( length )\r\n\t{\r\n\t\treturn new Array( length ).fill( 0 );\r\n\t}\r\n\r\n\r\n\t/**\r\n\t *\r\n\t * @param array\r\n\t * @returns {array}\r\n\t */\r\n\tstatic cloneArray( array )\r\n\t{\r\n\t\treturn array.slice( 0 );\r\n\t}\r\n\r\n\r\n\t/**\r\n\t *\r\n\t * @param min\r\n\t * @param max\r\n\t * @returns {number}\r\n\t */\r\n\tstatic getRandomIntBetween( min, max )\r\n\t{\r\n\t\tlet minCeil  = Math.ceil( min ),\r\n\t\t\tmaxFloor = Math.floor( max )\r\n\t\t;\r\n\r\n\t\treturn Math.floor( Math.random() * (maxFloor - minCeil + 1) ) + minCeil;\r\n\t}\r\n\r\n};\n\n//# sourceURL=webpack://Nonogram/./src/nonogram/utility.js?");

/***/ }),

/***/ 0:
/*!****************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** multi ./src/nonogram/nonogram.js ./src/nonogram/puzzle.js ./src/nonogram/puzzle-cell.js ./src/nonogram/puzzle-line.js ./src/nonogram/utility.js ./src/nonogram/creator.js ./src/nonogram/solver.js ./src/nonogram/gui.js ./src/nonogram/gui-template.js ./src/nonogram/export.js ***!
  \****************************************************************************************************************************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("__webpack_require__(/*! C:\\Users\\monkeyArms\\Desktop\\Graphics\\aa-CLIENT PROJECTS\\Aaron Fisher\\web\\experiments\\nonogram\\src\\nonogram\\nonogram.js */\"./src/nonogram/nonogram.js\");\n__webpack_require__(/*! C:\\Users\\monkeyArms\\Desktop\\Graphics\\aa-CLIENT PROJECTS\\Aaron Fisher\\web\\experiments\\nonogram\\src\\nonogram\\puzzle.js */\"./src/nonogram/puzzle.js\");\n__webpack_require__(/*! C:\\Users\\monkeyArms\\Desktop\\Graphics\\aa-CLIENT PROJECTS\\Aaron Fisher\\web\\experiments\\nonogram\\src\\nonogram\\puzzle-cell.js */\"./src/nonogram/puzzle-cell.js\");\n__webpack_require__(/*! C:\\Users\\monkeyArms\\Desktop\\Graphics\\aa-CLIENT PROJECTS\\Aaron Fisher\\web\\experiments\\nonogram\\src\\nonogram\\puzzle-line.js */\"./src/nonogram/puzzle-line.js\");\n__webpack_require__(/*! C:\\Users\\monkeyArms\\Desktop\\Graphics\\aa-CLIENT PROJECTS\\Aaron Fisher\\web\\experiments\\nonogram\\src\\nonogram\\utility.js */\"./src/nonogram/utility.js\");\n__webpack_require__(/*! C:\\Users\\monkeyArms\\Desktop\\Graphics\\aa-CLIENT PROJECTS\\Aaron Fisher\\web\\experiments\\nonogram\\src\\nonogram\\creator.js */\"./src/nonogram/creator.js\");\n__webpack_require__(/*! C:\\Users\\monkeyArms\\Desktop\\Graphics\\aa-CLIENT PROJECTS\\Aaron Fisher\\web\\experiments\\nonogram\\src\\nonogram\\solver.js */\"./src/nonogram/solver.js\");\n__webpack_require__(/*! C:\\Users\\monkeyArms\\Desktop\\Graphics\\aa-CLIENT PROJECTS\\Aaron Fisher\\web\\experiments\\nonogram\\src\\nonogram\\gui.js */\"./src/nonogram/gui.js\");\n__webpack_require__(/*! C:\\Users\\monkeyArms\\Desktop\\Graphics\\aa-CLIENT PROJECTS\\Aaron Fisher\\web\\experiments\\nonogram\\src\\nonogram\\gui-template.js */\"./src/nonogram/gui-template.js\");\nmodule.exports = __webpack_require__(/*! C:\\Users\\monkeyArms\\Desktop\\Graphics\\aa-CLIENT PROJECTS\\Aaron Fisher\\web\\experiments\\nonogram\\src\\nonogram\\export.js */\"./src/nonogram/export.js\");\n\n\n//# sourceURL=webpack://Nonogram/multi_./src/nonogram/nonogram.js_./src/nonogram/puzzle.js_./src/nonogram/puzzle-cell.js_./src/nonogram/puzzle-line.js_./src/nonogram/utility.js_./src/nonogram/creator.js_./src/nonogram/solver.js_./src/nonogram/gui.js_./src/nonogram/gui-template.js_./src/nonogram/export.js?");

/***/ })

/******/ })["default"];
});